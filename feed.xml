<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Yilin's Blog</title>
    <description>Yilin Zhang's personal blog.
</description>
    <link>http://yilin-zhang.github.io/</link>
    <atom:link href="http://yilin-zhang.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 01 Mar 2020 12:15:24 -0500</pubDate>
    <lastBuildDate>Sun, 01 Mar 2020 12:15:24 -0500</lastBuildDate>
    <generator>Jekyll v4.0.0</generator>
    
      <item>
        <title>Off-topic | 质量、数量和习惯</title>
        <description>&lt;p&gt;博客到底应该怎么写？&lt;/p&gt;

&lt;p&gt;对于这个问题，不同人可能会给出截然不同的答案。有些人喜欢精心雕琢，更新周期长但出
产高质量内容，而另外一些人可能喜欢经常发表自己的观点、见解和经验。当然也有人二者
得兼的。&lt;/p&gt;

&lt;p&gt;而撰写博客的初衷并不止于此。有些人也许从来没有从数量和质量的角度思考这个问题，而
是从「博客能为自己带来什么」的想法起步。这样想的人可能并不会过多考虑自己的内容能
为别人带去什么，而是能为自己带来什么。&lt;/p&gt;

&lt;p&gt;回顾博客的起源，就会发现它从一开始就是一种文字为主的记录形式，而且是生活类的居多。
而如今博客也已式微，基本被微博所取代，也许很多的用户被分流到并不冠以「博客」之名
的平台（比如豆瓣日记）。而当下仍然坚持写博客的人，很多是所谓的「程序员」，可能一
方面是国内某些面向程序员的博客平台存在，另一方面是程序员是相对少数有能力自己搭建
博客的人群。但抛去这个名义上的「博客」一词来看，大家本质上却是在做一样的事情，因
为只要是互联网上的个人文字分享，都应被归类为「写博客」。在这么多博客当中，又有多
少是真正考虑到读者的呢？&lt;/p&gt;

&lt;p&gt;这样一看，数量和质量的讨论变得不那么重要了。博客并不要求作者担任自己的杂志主编，
要保证自己的销路，而更像是结绳记事。在这个年代，博客这个形式本身就已经意味着不会
有过多的流量涌入，因为相比之下，一个没有精准推荐算法和精美UI的平台就像是一个荒蛮
世界，除了自己没有太多的人会来关注。除非自己在真实世界中有一定的人气或威望，使得
他人会专程来点开自己的博客，否则大多时候都是自己在经营。我也相信在当下坚持写博客
的人并不追逐流量，要不然也不会在这个阵地坚守下去了。&lt;/p&gt;

&lt;p&gt;所以「写博客」本质上更像是一种习惯。这个习惯不能保证自己会变得更好，但起码能满足
自己想在一个没有流量充斥的地方记事的冲动。无论是否和学习、技术有关，无论是否对读
者有所帮助，哪怕读者只有作者一个人，文字的记录都是值得的。当自己想要拓宽读者群体
时，也许质量与数量的讨论是有益的，但只是对大多数人来说，这并不应该是必需品。&lt;/p&gt;

</description>
        <pubDate>Wed, 19 Feb 2020 00:00:00 -0500</pubDate>
        <link>http://yilin-zhang.github.io/off-topic/2020/02/19/off-topic-quality-quantity-habit.html</link>
        <guid isPermaLink="true">http://yilin-zhang.github.io/off-topic/2020/02/19/off-topic-quality-quantity-habit.html</guid>
        
        <category>Linux</category>
        
        <category>文件管理</category>
        
        
        <category>Off-topic</category>
        
      </item>
    
      <item>
        <title>Conversation | AI与艺术创作</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;这个专栏记录了我和准漫画家兄弟的聊天内容。正文完全以对话形式呈现。这么做的主要原因是自己偷懒，不想把所有内容重新整理，然后写一篇大作文。而且当下，一段只有一句的文章才是主流。&lt;/p&gt;

&lt;p&gt;这次的讨论话题是「AI与艺术创作」。究竟AI是否适合艺术创作？&lt;/p&gt;

&lt;p&gt;加粗的段落代表「我」，其他段落代表「兄弟」。&lt;/p&gt;

&lt;h1 id=&quot;对话&quot;&gt;对话&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;说起来我又有了一点感悟。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;你说。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;当机器学习得到的艺术效果和随机数生成的效果不分伯仲的时候，机器学习还有意义吗？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;好问题。&lt;/p&gt;

&lt;p&gt;应该没有意义吧?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我现在越来越感觉到机器学习在艺术领域存在滥用。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果是实验性质的，我完全支持。但如果你追求结果，并且希望这是个学习的过程，那机器学习会有负面作用。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;你的意思是，本质上来说，机器学习并没有能超越随机数生产的艺术效果？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;随机数+手工规则往往还好于深度学习。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;甚至跟随机数一样……&lt;/p&gt;

&lt;p&gt;甚至随机数更好。&lt;/p&gt;

&lt;p&gt;因为人类做不到随机数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我觉得问题在这里：艺术这个东西必须要藉由「人」来阐述。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这很有意思。&lt;/p&gt;

&lt;p&gt;你想，我对你说「随机猜个1到100」，其实你的答案是有规律的，你会有偏爱的数字，或者你选了一个数字，下次就不会选了，但机器的随机数就是真的随机数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;是的，不过你这个例子有点类似随机数+手工规则vs不受控制的随机数。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当然。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我是这么想的：艺术是比较个人化（personal）的，比如不同的钢琴家演绎同一个曲子是不一样的。而机器学习坏就坏在，没有个性（personality）。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;但是手工规则可以。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;你即便输入上亿的曲子做训练，即便能让机器懂得音乐的规律，那也最多也只能做到音阶、和弦这种有共性/共识的东西，因为这是大部分音乐的交集。如果一百个人有一百种阐释，机器学不会那个个性或是偏好，并且因为个性化、偏好的成因过于复杂，纯数据很难抓到构成其根本的东西。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;但是为什么手工规则+随机数好呢？因为人在手工的部分实际上控制了随机，加入了个性的部分。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;懂了。&lt;/p&gt;

&lt;p&gt;wow！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;因为你知道概率分布了，它某种程度也是一种决定性（deterministic）的东西，不全是随机（stochastic）。虽然学界不是这么理解和分类的，但我相信从人类主观选择的角度是这样。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;那做初级的应用，是不是就是效果器。比如给声音加上颤音，本质上就是给do这个音加上一种随机效果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;有点类似，比如说你想让这个颤音调制没有固定的频率，随机就有用了。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对的。&lt;/p&gt;

&lt;p&gt;但是音阶，和声，都还是人类的做的，本质上也是一种手工规则。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;现在很多的误用是，把无法控制的随机（AI）当随机用。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;而且曾经的算法作曲我认为才是真正的算法作曲。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这又牵扯到我觉得很关键的一点：可解释性。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;请说。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我觉得真正的艺术是需要有意图（intention）的，虽然你的表达可以没有什么具体的意义。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个有意思。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;意图的表现是需要刻意为之的，即便那个刻意可以是你表现为不刻意的刻意。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;很绕……&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;比如说在纸上乱画，你事先安排自己就是要乱画，虽然过程是无目的的乱画。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;即使是最抽象的现代艺术，本质上也是intentional的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;没错。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;那么可解释性就是说，我要有能力解读我自己的作品。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果你刻意用AI制造AI的效果，那就有艺术性了。但是很多时候并没有。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;比如我要AI作曲，我要的结果是做出来的曲子好听，但是注意，这个不是艺术创作中的「意图」，有本质区别。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;当你这么做的时候，你实际上把决定权交给了机器，而机器是个黑箱。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;AI制作的艺术的艺术性并不在于AI制造的艺术本身，而在于「AI制造」这四个字。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;你get到了。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I get it。&lt;/p&gt;

&lt;p&gt;那些算法，只是制造黑箱的方法，而不是黑箱里的东西。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;黑箱里的东西你无法解读，那么相比之下艺术性就少很多了，你只能从「结果好不好听」这个肤浅的层次去理解。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;机器学习的算法是这样的，但是以前有些基于数学的算法，有明确的公式，那就不是黑箱了。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;那些基于明确公式的算法有点像管道制造。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;是的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;你不觉得当下有关机器学习的一切都十分刻意吗？曾经的照相机和电吉他都是不经意间发明的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;是的，有点病态了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;因为当时有了新技术，而且这个技术也比较成熟了，新艺术就顺势出来，为人类新添了很多艺术表达方式。但是现在机器学习/深度学习刚刚起步，而且上来就要妄图代替人类独有的艺术表达能力。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我不反对（甚至是支持）用机器学习增强表现力，在简单的任务上，机器可以fake出人类的那个intention。但这是有个阈值的，我觉得手工规则+随机就是一个阈值。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;好像有点get到了。&lt;/p&gt;

&lt;p&gt;弱人工智能本质上始终无法与随机数匹敌。在真正的强人工智能（可能永远不会出现）之前，都是没意义的，或者说意义很小。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这个和非艺术领域的机器学习有那么一点点像（但并不一样，艺术相关的东西更复杂了），如果神经网络无法打败手工特征，那也没有意义。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;所以我觉得弱人工智能不适合艺术创作，仅适合于增强表现力，也就是把部分的人类创作交给黑箱，让结果变漂亮，本质上是提升浅层次的审美（比如是否悦耳）。虽然我觉得从艺术本质上是扣分的，但如果只追求浅层次的审美结果也没什么。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;最开始的艺术都是好听和好看，比如古典绘画、古典音乐，但他们都没有触及本质。&lt;/p&gt;

&lt;p&gt;艺术像数学一样，一开始数学都是为了计算一个苹果和两个苹果等于三个苹果，但背后的数学/艺术是某种别的更本质的东西&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;没错，我感觉数学也是艺术了。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我也这么觉得！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;艺术的本质可能可以回归数学，但是不应该是数据。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这就是每本艺术史都在说但不明说的东西：「漂亮不是艺术」。&lt;/p&gt;

&lt;p&gt;艺术能帮我们达到美、好看，但他还可以去很多地方，来自于应用又会回馈于应用但本质绝非应用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;是的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;总之还是需要人类。&lt;/p&gt;

&lt;p&gt;人工智能这个话题太大了，很多时候我们只是在灌水，全是垃圾。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对的，而且大多时候，技术上的事情让那些AI专家做就可以了，其他领域的人应该只把AI当工具。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这个黑箱还有个很大的缺点，那就是会让你失去对事物本质了解的兴趣。就我们系而言，太多人都在搞机器学习，但我觉得应该把注意力放在声音（sound）上。信号生成处理、编程、交互设计、音乐认知和感知……这些才是根本。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果是在音乐信息检索的角度，使用机器学习我觉得合情合理，甚至相当合适，但是如果去做音乐创作，那可能就得再想想了。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不需要机器学习就可以做到的，宁愿不用机器学习。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;还是要分清主次。&lt;/p&gt;

&lt;p&gt;比如对漫画来说，画技是没那么重要的。机器学习音乐应该也是这样，音乐才是根本。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;没错，要关注的是音乐，或者说宽点就是声音。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;所以这就是我最近渐渐想通的事情。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我相信所有那些去做莫名其妙的事情的艺术家，起码都理解了“艺术”是什么。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我也想想通……&lt;/p&gt;

&lt;p&gt;最近算是小半个瓶颈期吧。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我觉得大兄弟已经想通很多东西了吧。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我也学到了一课，艺术，intention。&lt;/p&gt;

&lt;p&gt;其实我想的还是关于比较通俗的东西。&lt;/p&gt;

&lt;p&gt;我现在有点理解，通俗艺术家的本质是一个桥梁。沟通着艺术家和观者的桥梁。&lt;/p&gt;

&lt;p&gt;我还不能很好的说清楚。纯艺也许无关欣赏，重点是intention这件事情。桥梁本身重要，而不是结果和出发点。&lt;/p&gt;

&lt;p&gt;（完）&lt;/p&gt;
</description>
        <pubDate>Sun, 24 Nov 2019 00:00:00 -0500</pubDate>
        <link>http://yilin-zhang.github.io/conversation/2019/11/24/conversation-ai-art-creation.html</link>
        <guid isPermaLink="true">http://yilin-zhang.github.io/conversation/2019/11/24/conversation-ai-art-creation.html</guid>
        
        <category>艺术</category>
        
        <category>AI</category>
        
        
        <category>Conversation</category>
        
      </item>
    
      <item>
        <title>Tutorial | Linux 音频系统搭建</title>
        <description>&lt;p&gt;Linux 下的音频系统搭建要比 Windows 和 MacOS 复杂很多，因为上层应用不会来帮用户解决底层系统软件的问题，因此用户就需要处理更多的细节。不过虽说刚开始会感到复杂，一旦理解就感觉很直观了。&lt;/p&gt;

&lt;p&gt;可惜的是，国内几乎没有关于 Linux 音频方面的介绍。我当初搭建 Linux 的音频制作环境也是在 Google 和 Youtube 上摸索了很久（当时用的发行版是 Ubuntu，不像 Arch Linux 有详尽的 Wiki）。最近找到的一个网站&lt;a href=&quot;https://lado.me&quot;&gt;啦哆咪&lt;/a&gt;可能是国内仅存的关于 Linux 音频/音乐制作的网站。里面有很多实用的内容，并且作者还搭建了一个 Arch Linux 的音乐软件仓库，是相当用心了。（虽然我个人更愿意使用 AUR 。）&lt;/p&gt;

&lt;p&gt;这篇博客的主要目的是手把手的 Linux 音频配置教学，不涉及任何原理细节（因为自己现在也是一知半解）。希望自己有能完全搞明白的一天。&lt;/p&gt;

&lt;p&gt;在阅读下面的内容之前，推荐先了解一下 Linux 的音频组件是怎么连接的。可以参考啦哆咪的&lt;a href=&quot;https://lado.me/2017/04/16/combination-of-linux-audio/&quot;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;

&lt;h1 id=&quot;软件仓库&quot;&gt;软件仓库&lt;/h1&gt;

&lt;p&gt;对于 Ubuntu 用户来说，使用 KXStudio 仓库是主流的选择。查看添加仓库的方法可以进入&lt;a href=&quot;https://kx.studio/Repositories&quot;&gt;这个链接&lt;/a&gt;。该仓库提供了非常全面的与音频制作相关的软件，涵盖了相当多 Ubuntu 官方仓库没有的插件。&lt;/p&gt;

&lt;p&gt;对于 Arch Linux 用户来说，因为有 AUR ，所以自然不是问题。&lt;/p&gt;

&lt;p&gt;最复杂的就是下面关于 JACK 的配置了。&lt;/p&gt;

&lt;h1 id=&quot;jack&quot;&gt;JACK&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;JACK 是 JACK Audio Connection Kit 的递归缩写，是一个专业的音频服务守护进程，能在使用其 API 的应用之间提供实时、低延迟的音频和 MIDI 数据连接。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这一段来自 &lt;a href=&quot;https://wiki.archlinux.org/index.php/JACK%5FAudio%5FConnection%5FKit&quot;&gt;Arch Wiki&lt;/a&gt; ，是我自己翻译的。&lt;/p&gt;

&lt;p&gt;如果不想看英文的 Arch Wiki ，还可以看&lt;a href=&quot;https://lado.me/2017/04/15/introduce-jack/&quot;&gt;啦哆咪&lt;/a&gt;上对 JACK 的介绍，这篇文章还介绍了 JACK 的安装方法，照做即可。&lt;/p&gt;

&lt;p&gt;我个人喜欢用 Cadence （软件包： &lt;code class=&quot;highlighter-rouge&quot;&gt;cadence&lt;/code&gt; ）这个 &lt;code class=&quot;highlighter-rouge&quot;&gt;jack2&lt;/code&gt; 前端 GUI 软件。因此安装的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;jack2&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;在安装完 JACK 后，还需要进行一定的配置。对于 Arch 用户直接参考 JACK 的 &lt;a href=&quot;https://wiki.archlinux.org/index.php/JACK%5FAudio%5FConnection%5FKit&quot;&gt;Arch Wiki&lt;/a&gt; 即可，这里只是简单提一下。&lt;/p&gt;

&lt;p&gt;首先需要将用户加入 &lt;code class=&quot;highlighter-rouge&quot;&gt;audio&lt;/code&gt; 用户组。将用户加入已有用户组的命令参考如下：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;usermod &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-G&lt;/span&gt; audio &amp;lt;your user name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其次，如果是 Arch Linux 用户，推荐安装 &lt;code class=&quot;highlighter-rouge&quot;&gt;realtime-privileges&lt;/code&gt; 包，安装完成后将用户加入 &lt;code class=&quot;highlighter-rouge&quot;&gt;realtime&lt;/code&gt; 用户组。注销后重新登录生效。&lt;/p&gt;

&lt;p&gt;另外，为了能在使用 JACK 时同时能使用 PulseAudio ，需要使用一个 bridge 将 PulseAudio 的音频通过 JACK 。如果不这么做，在开启 JACK 服务时是无法使用桌面应用（比如浏览器）播放音频的。对于 Ubuntu 用户，需要安装 &lt;code class=&quot;highlighter-rouge&quot;&gt;pulseaudio-module-jack&lt;/code&gt; ，对于 Arch 用户需要安装 &lt;code class=&quot;highlighter-rouge&quot;&gt;pulseaudio-jack&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;对 Arch Linux 用户而言，还需要安装 &lt;code class=&quot;highlighter-rouge&quot;&gt;alsa-utils&lt;/code&gt; ，否则 JACK 无法使用由 ALSA 驱动的输入输出设备。&lt;/p&gt;

&lt;p&gt;接下来到了 JACK 的配置环节。这里以 Cadence 为例。打开 Cadence 后，首先在右下方的 JACK Bridges 的 ALSA Audio 标签中选择 「ALSA -&amp;gt; PulseAudio -&amp;gt; JACK (Plugin)」。之后点击 「Configure」在 Driver 标签下的 ALSA 标签选择，在这里可以选择输入和输出对应的硬件设备。还可以调整采样率和缓冲区大小。（采样率一般用 44100 ，缓冲区大小设置为 256 是个不错的选择。）&lt;/p&gt;

&lt;p&gt;设置结束后，回到 Cadence 的主菜单，点击「Start」。不出意外的话应该不会报错，如果报错了，可以去「Tools」-&amp;gt;「Logs」查看日志，上网搜索解决方案（一定要使用英文搜索引擎）。顺便一提，对 Arch 用户来说如果需要使用 Cadence 提供的其他工具，需要安装 &lt;code class=&quot;highlighter-rouge&quot;&gt;a2jmidid&lt;/code&gt; ，否则那些工具无法打开。&lt;/p&gt;

&lt;p&gt;如果 JACK 正常启动了，那么基本就要成功了。接下来需要做的是安装 Pavucontrol （软件包： &lt;code class=&quot;highlighter-rouge&quot;&gt;pavucontrol&lt;/code&gt; ） 这个 PulseAudio 的前端控制软件。可以先使用浏览器或是本地的影音软件打开一个音频或视频，在「回放」这个标签栏的最下方选择显示「All Streams」，确认显示的对应的音频流使用的是「JACK Sink」（如果不是就调整过来）。&lt;/p&gt;

&lt;p&gt;现在应该能正常听到声音了。到此 JACK 的配置工作就基本完成。&lt;/p&gt;

&lt;p&gt;注意接下来提到的软件都需要在 JACK 运行时使用。&lt;/p&gt;

&lt;h1 id=&quot;音序器&quot;&gt;音序器&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://rosegardenmusic.com&quot;&gt;Rosegarden&lt;/a&gt; （软件包： &lt;code class=&quot;highlighter-rouge&quot;&gt;rosegarden&lt;/code&gt; ） 是 Linux 下最好用的原生音序器。&lt;/p&gt;

&lt;p&gt;安装 Rosegarden 后用其打开 MIDI 文件，会发现没有声音。因为 Rosegarden 本身并不包含 soundfont ，也不自带合成器。&lt;/p&gt;

&lt;p&gt;合成器一般使用 Fluidsynth （软件包： &lt;code class=&quot;highlighter-rouge&quot;&gt;fluidsynth&lt;/code&gt; ） ，推荐安装它的一个前端工具叫做 Qsynth （软件包： &lt;code class=&quot;highlighter-rouge&quot;&gt;qsynth&lt;/code&gt; ），安装 Qsynth 会自动将 Fluidsynth 作为依赖安装。Arch Linux 还将 Fluidsynth 的 soundfont 独立成一个包 &lt;code class=&quot;highlighter-rouge&quot;&gt;soundfont-fluid&lt;/code&gt; ，需要额外安装，而 Ubuntu 不需要。&lt;/p&gt;

&lt;p&gt;安装好后，打开 Qsynth ，进入「Setup」-&amp;gt;「Soundfonts」，添加一个新的 soundfont 。在这里选择安装好的 Fluidsynth Soundfont，路径是： &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/share/soundfonts/FluidR3_GM.sf2&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;这时候用 Rosegarden 打开 MIDI 文件，应该能听到声音了。&lt;/p&gt;

&lt;p&gt;也就是说，在使用 Rosegarden 前，需要先使用 Qsynth 开启 Fluidsynth 。&lt;/p&gt;

&lt;h1 id=&quot;daw&quot;&gt;DAW&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://ardour.org&quot;&gt;Ardour&lt;/a&gt; （软件包： &lt;code class=&quot;highlighter-rouge&quot;&gt;ardour&lt;/code&gt; ） 是 Linux 下最好用的 DAW 。&lt;/p&gt;

&lt;p&gt;虽然 Ardour 是开源软件，但推荐的做法是去 Ardour 的官网上付费下载（可以选择任意价格捐赠），毕竟开发这种软件相当不容易。如果想使用发行版仓库的版本，也可以考虑捐一下款。&lt;/p&gt;

&lt;p&gt;这里再给出一个 Ardour 的教程以供参考：&lt;a href=&quot;http://brunoruviaro.github.io/ardour4-tutorial/&quot;&gt;BEGINNER’S TUTORIAL - Ardour 4&lt;/a&gt; 。有能力的可以上 Youtube 找到更多的教学视频。更详细的信息可以参考&lt;a href=&quot;http://manual.ardour.org&quot;&gt;官方手册&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;如果想做电子音乐，LMMS（软件包： &lt;code class=&quot;highlighter-rouge&quot;&gt;lmms&lt;/code&gt; ）是一个不错的的 FL Studio 替代品，当然功能没有 FL Studio 那么强大。&lt;/p&gt;

&lt;h1 id=&quot;插件&quot;&gt;插件&lt;/h1&gt;

&lt;p&gt;Linux 上支持的原声插件是 LADSPA （Linux Audio Developer’s Simple Plugin API）和 LV2 （LADSPA Version 2）插件 。LV2 是使用最多的插件。基本上常用的插件都可以在 KXStudio 仓库或者 AUR 中找到。&lt;/p&gt;

&lt;p&gt;我使用过的插件不多，只推荐一些常用的（Linux 有非常丰富的插件等着大家去发现）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;合成器
    &lt;ul&gt;
      &lt;li&gt;ZynAddSubFX&lt;/li&gt;
      &lt;li&gt;Zyn-Fusion（推荐，更好的 ZynAddSubFX 前端界面）&lt;/li&gt;
      &lt;li&gt;Yoshimi（适合做弦乐和风琴）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;采样器
    &lt;ul&gt;
      &lt;li&gt;DrMr（用于加载hydrogen音源）&lt;/li&gt;
      &lt;li&gt;Fabla&lt;/li&gt;
      &lt;li&gt;Drumkv1&lt;/li&gt;
      &lt;li&gt;Drumgizmo&lt;/li&gt;
      &lt;li&gt;avldrums&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;效果
    &lt;ul&gt;
      &lt;li&gt;Calf 系列插件（强烈推荐）&lt;/li&gt;
      &lt;li&gt;Guitarix 系列插件&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;midi-键盘&quot;&gt;MIDI 键盘&lt;/h1&gt;

&lt;p&gt;为了在 Ardour 中使用 MIDI 键盘，要在终端开启 JACK MIDI &amp;lt;-&amp;gt; ALSA sequencer MIDI bridge。&lt;/p&gt;

&lt;p&gt;需要在终端运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;a2jmidid&lt;/code&gt; （需要安装同名软件包）：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;a2jmidid &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;具体可以参考&lt;a href=&quot;http://manual.ardour.org/setting-up-your-system/setting-up-midi/midi-on-linux/&quot;&gt;Ardour官方手册&lt;/a&gt;。&lt;/p&gt;

&lt;h1 id=&quot;软件效果器&quot;&gt;软件效果器&lt;/h1&gt;

&lt;p&gt;这里重点介绍的是 &lt;a href=&quot;http://guitarix.org&quot;&gt;Guitarix&lt;/a&gt; ，使用它能让我们带上耳机练琴。设置步骤如下：&lt;/p&gt;

&lt;p&gt;首先在 Cadence 中设置输入设备为自己的 USB 声卡，再运行。&lt;/p&gt;

&lt;p&gt;第二步，打开 Guitarix ，挑选自己需要的效果，组成效果链路。&lt;/p&gt;

&lt;p&gt;第三步，打开 Cadence 的工具 Catia 。可以看到系统中所有软件音频接口的连接，将系统音频输入连接到 Guitarix 的输入，将 Guitarix 的输出（一般是双声道）分辨连接到两个系统 playback 。&lt;/p&gt;

&lt;p&gt;设置完成后之后就可以听到自己乐器的声音了。&lt;/p&gt;

&lt;h1 id=&quot;其他&quot;&gt;其他&lt;/h1&gt;

&lt;h2 id=&quot;打谱&quot;&gt;打谱&lt;/h2&gt;

&lt;p&gt;如果是五线谱制作，最简单的就是使用 &lt;a href=&quot;https://musescore.org&quot;&gt;MuseScore&lt;/a&gt; ，运行它无需开启 JACK 。如果想要制作更加复杂或者排版精良的乐谱，可以使用 GNU 的软件 &lt;a href=&quot;http://lilypond.org&quot;&gt;LilyPond&lt;/a&gt; ，它使用一套标记语言，最后渲染成乐谱（类似于 LaTeX）。&lt;/p&gt;

&lt;p&gt;Linux 下也有 Guitar Pro 的替代品——&lt;a href=&quot;http://tuxguitar.com.ar/&quot;&gt;TuxGuitar&lt;/a&gt;。Ubuntu 用户可以去官方网站下载 deb 包，Arch 用户可以在 AUR 找到。由于 TuxGuitar 是用 Java 开发的，需要安装 JRE 才可以运行。因为这个软件很长时间没有用，现在也没有安装，不确定是否需要 JACK 。&lt;/p&gt;

&lt;h2 id=&quot;鼓机&quot;&gt;鼓机&lt;/h2&gt;

&lt;p&gt;最常用的就是 &lt;a href=&quot;http://hydrogen-music.org/&quot;&gt;Hydrogen&lt;/a&gt; 了。&lt;/p&gt;

&lt;h2 id=&quot;简单录音&quot;&gt;简单录音&lt;/h2&gt;

&lt;p&gt;如果只是想简单录音，可以直接使用 &lt;a href=&quot;https://www.audacityteam.org/&quot;&gt;Audacity&lt;/a&gt; ，这个软件不需要 JACK 也可以运行。&lt;/p&gt;

&lt;h1 id=&quot;后记&quot;&gt;后记&lt;/h1&gt;

&lt;p&gt;这篇博客只是流水帐式的简单过一遍 Linux 下的音频配置方法。一些更深入的内容（比如利用 Carla 和 Wine 运行 VST 插件）没有提到。不过我相信上面提到的内容已经足够日常的练习和 Demo 制作了。&lt;/p&gt;

&lt;p&gt;使用 Linux 进行音频制作本身就是一个小众的领域，工业级的优质软件相比 Windows 和
MacOS 还是少之又少。但是了解并使用 Linux 制作音乐确实是一件很有意思的事情，尤其
是几乎所有的软件都是自由软件，意味着能够免费获取和自由修改源代码，不需要花大价钱
购买商业软件，或者费力气去破解（从来都不推荐这么做），用户也可以借助软件仓库简单
快速获得大部分需要的插件。虽然 Linux 的插件选择有限，但对于非工业级的音乐制作来
说，有限的选项可能反而是件好事。对于半专业的音乐制作，Linux 也足够满足人们的需求。&lt;/p&gt;

&lt;p&gt;此外，善于使用英文搜索也是十分重要的。Linux 自身的很多信息都只能通过英文搜索获得，更不必说关于 Linux 的音乐制作信息了，在这方面国内算得上是一片空白。使用 Bing 是个不错的选择，有能力的话当然是用 Google 了。&lt;/p&gt;

&lt;p&gt;最后推荐一个论坛叫做 &lt;a href=&quot;https://linuxmusicians.com/&quot;&gt;LinuxMusicians&lt;/a&gt; ，里面都是关
于使用 Linux 进行音乐制作的讨论，你可以在里面得到很多有益的帮助。我曾经为了提取
一个 VST 插件内置的 MIDI 文件，在这个论坛上找到了一个网友写的 Ruby 脚本（可能这
里的 musicians 都是 hackers 吧^^）。&lt;/p&gt;
</description>
        <pubDate>Sat, 13 Apr 2019 00:00:00 -0400</pubDate>
        <link>http://yilin-zhang.github.io/tutorial/2019/04/13/tutorial-linux-audio-setup.html</link>
        <guid isPermaLink="true">http://yilin-zhang.github.io/tutorial/2019/04/13/tutorial-linux-audio-setup.html</guid>
        
        <category>Linux</category>
        
        <category>音频</category>
        
        
        <category>Tutorial</category>
        
      </item>
    
      <item>
        <title>Off-topic | 如何管理自己的文件</title>
        <description>&lt;p&gt;Off-topic 是一个新开的分类，讨论其它有趣的话题。&lt;/p&gt;

&lt;p&gt;这次的话题是 Linux 下的文件管理。&lt;/p&gt;

&lt;p&gt;我觉得 Linux 有一种让人养成良好习惯的力量，这其中就包括养成管理文件的习惯。&lt;/p&gt;

&lt;p&gt;我们在日常使用中会产生很多文件，也许是记录工作内容的文本文档、MS Office文档，或者是一些应用程序的配置文件和日志文件。如果不加以整理，很容易发生下面几个问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;经常找不到文件；&lt;/li&gt;
  &lt;li&gt;经常误删文件；&lt;/li&gt;
  &lt;li&gt;在重装系统后或使用另一个系统时，难以还原熟悉的配置。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前两个问题和个人文件整理有关，最后一个问题和配置文件有关。&lt;/p&gt;

&lt;h1 id=&quot;个人文件&quot;&gt;个人文件&lt;/h1&gt;

&lt;p&gt;先来说个人文件整理。这点对很多人来说可能是最有用的。这里说的「个人文件」主要指的是个人文档，比如 MS Office 文档（实验报告、项目申请书、电子表格等）、代码源文件之类。音乐、电影这些，相信大家也不会找不到吧XD。&lt;/p&gt;

&lt;p&gt;我总结一下自己管理个人文件的一些经验，大致分为四点：分类、归档、软链接和回收站。&lt;/p&gt;

&lt;h2 id=&quot;分类&quot;&gt;分类&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;文件的分类是这四点中最重要的。良好的分类可以大大降低找不到文件或者误删文件的概率。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;其中最重要的是搞清楚要把文件放在哪里。&lt;/p&gt;

&lt;p&gt;拿 Linux 中用户的家目录来说，有很多软件会将他们的配置文件或是存放配置文件的目录，直接放在这个目录下面，一般这些文件或目录都是以 &lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt; 开头的隐藏文件或目录。除此之外，有些软件的工程目录也会放在家目录下（比如 Ardour），或者也会放在家目录的「文档」目录下（比如 MuseScore）。如果直接将个人文件不加区别地和这些文件放在一起，很难做整理。&lt;/p&gt;

&lt;p&gt;但这些目录就真的没有用了吗？也未必。不同的目录的作用不同。我们不妨将「个人文件」分为三个等级：用户域、项目域、个人域。（这三个词都是我自创的 XD）&lt;/p&gt;

&lt;p&gt;家目录是用来存放「用户域」的文件的，包括一些用户专属的本地软件，编程语言相关的目录。这些一般都不算是狭义上的「个人文件」。除此之外，一些非常常用的文件也可以直接放在家目录下，或者在家目录下新建一个目录放置，比如常用的脚本，经常打开的笔记文件等等。&lt;/p&gt;

&lt;p&gt;「文档」目录实际上比家目录干净得多，因此可以存放「项目域」文件。比如当前写的代码的源文件或工程文件就可以直接在「文档」下面新建目录放置。&lt;/p&gt;

&lt;p&gt;为了保存个人的文档（课件、实验报告、项目申请书、论文等），我的习惯是单独建立一个目录，将所有的文件放在这个目录下面。具体的位置无所谓（我自己是放在「文档」下）。&lt;/p&gt;

&lt;p&gt;做到了这一点，其实就已经分类得很不错了。再下来就是各个目录内部的细分。不过这件事相信大家都知道应该怎么做，只要找到适合自己的方法即可。&lt;/p&gt;

&lt;h2 id=&quot;归档&quot;&gt;归档&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;适时归档，keep yourself simple 。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果你已经将所有个人文件都分类存放了，那很好。但是如果不适时归档，当东西越来越多，你也就越来越难找到想到的文件。&lt;/p&gt;

&lt;p&gt;人是懒惰的，尤其是当自己的硬盘有 1TB 的时候。&lt;/p&gt;

&lt;p&gt;另一个适时归档的理由是，如果哪一天需要备份文件，那么也许有将近 1TB 的个人文件躺在硬盘里等着你。&lt;/p&gt;

&lt;p&gt;人是懒惰的，尤其是宁愿花钱充会员也不愿省钱买一个移动硬盘的时候。&lt;/p&gt;

&lt;p&gt;没错，这个问题的答案很简答，买一个移动硬盘，每隔一段时间就将文件归档，存放在移动硬盘。自己硬盘上只留下有用的文件。&lt;/p&gt;

&lt;p&gt;另外，移动硬盘还能拿来做备份，一举两得。&lt;/p&gt;

&lt;h2 id=&quot;软链接&quot;&gt;软链接&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;软链接就是「快捷方式」，但比你想象的有用。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有了软链接，常用的文件夹就不必放在桌面了，而是可以按照上面说的分类方法存放，随后创建一个软链接放在桌面，指向自己的文件夹即可。&lt;/p&gt;

&lt;p&gt;这就是软链接的第一个用处——将工作目录和实际目录分开。&lt;/p&gt;

&lt;p&gt;我们总是可以在桌面上放置自己需要处理的文件，只不过这些文件都只是指向实际文件路径的软链接。这样就可以保证在文件合理分类的情况下，高效处理这些文件。等到文件处理完毕，暂时无需使用时，删除软链接即可。如果不使用软链接，每次就得在文件处理完毕时才分类，这会加大分类难度。因为文件数量在工作时往往会增多，文件越多，分类的成本就越大。而且堆积越多，人的惰性会让人越难处理这些文件。很多人的桌面上放着一大堆文件，往往是这个原因导致。&lt;/p&gt;

&lt;p&gt;软链接还有第二个用处——作为文件的引用而非拷贝，节省空间。&lt;/p&gt;

&lt;p&gt;学过编程的同学一定知道引用和拷贝的区别。假如你的两个工程目录下需要用到同一个数据集，但这个数据集有好几个G，那么较好的方法不是将数据集拷贝到两个工程目录下，而是在两个目录下放置指向这个数据集目录的软链接。对于文件系统而言，软链接和目录是有区别的，因为软链接本身只是一个指向文件目录的特殊文件。但是对于文件系统之上的应用程序，当需要访问指定路径时，软链接和目录并无区别。因此软链接作为目录的引用，能够为用户节省磁盘空间。&lt;/p&gt;

&lt;p&gt;软链接还有第三个用处——便于配置文件的管理。下文再提。&lt;/p&gt;

&lt;h2 id=&quot;回收站&quot;&gt;回收站&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;回收站是删除操作的缓冲区。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Shift+Del&lt;/code&gt; 或是使用命令行 &lt;code class=&quot;highlighter-rouge&quot;&gt;rm&lt;/code&gt; 一个文件是有风险的，因为这意味着永久删除。因此在做此操作前必须谨慎。&lt;/p&gt;

&lt;p&gt;不过在日常使用时，我们往往难以衡量当前想要删除的文件的重要程度，也不能确定我们一定不会误删。这时候将文件放到回收站是一个比较好的办法。&lt;/p&gt;

&lt;p&gt;回收站可以作为删除操作的缓冲区。先将文件放入回收站，过一段时间确认回收站中的文件确实无用后，再做彻底删除。&lt;/p&gt;

&lt;p&gt;如果使用命令行，可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;gio trash&lt;/code&gt; 命令将文件移动到回收站，而不是使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;rm&lt;/code&gt; 彻底删除。为了方便，可以起一个别名，比如我就使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;trash&lt;/code&gt; 命令代替 &lt;code class=&quot;highlighter-rouge&quot;&gt;gio trash&lt;/code&gt; ：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;alias &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;trash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'gio trash'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;配置文件&quot;&gt;配置文件&lt;/h1&gt;

&lt;p&gt;Linux 中的大部分配置文件是以 dotfiles 的形式存在的。这里的「配置文件」主要是用户常用的个性化定制文件，不包括多数 GUI 软件的配置文件。&lt;/p&gt;

&lt;p&gt;dotfiles 的意思其实就是以 &lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt; 开头的文件。在 Linux 中属于隐藏文件。这些文件往往是一些配置文件，一般都放在用户目录 &lt;code class=&quot;highlighter-rouge&quot;&gt;~&lt;/code&gt; 下面。比如 bash shell 的存在感很强的配置文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;.bashrc&lt;/code&gt; ，或者是 Emacs 的配置文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;.emacs&lt;/code&gt; 等。另外还有一些配置文件存放在以 &lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt; 开头的隐藏目录中。比如大多数软件的配置文件都存放在 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.config&lt;/code&gt; 目录下面。&lt;/p&gt;

&lt;p&gt;这些配置文件中，大部分是软件自行生成的，用户不太需要管理。而有些配置文件则经常被用户修改，比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;.bashrc&lt;/code&gt; 或 zshell 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;.zshrc&lt;/code&gt; 等。&lt;/p&gt;

&lt;h2 id=&quot;软链接-1&quot;&gt;软链接&lt;/h2&gt;

&lt;p&gt;软链接是管理配置文件的一个好办法。我们可以将所有的自定义配置文件统一放在同一个目录下，再软链接到 &lt;code class=&quot;highlighter-rouge&quot;&gt;~&lt;/code&gt; 下面。这么做方便了用户的管理，也方便移动。&lt;/p&gt;

&lt;p&gt;用户在查找自定义的配置文件时，可以直接进入自己的目录查看。这么做也不会出现因为忘了自己的 dotfile 叫什么名字而找不到的情况。另外当更换系统前备份时，也可以直接将该配置文件目录备份，这样就无需一个个找自己修改了哪些配置文件，确认哪些配置文件需要保留。在更换系统后，也可以很快地利用这些配置文件恢复自己熟悉的操作环境。&lt;/p&gt;

&lt;p&gt;当自己的配置文件越来越多时，可以考虑建立一个 git 仓库做版本管理，甚至可以考虑写一个脚本自动建立软链接，在新系统上做到一键配置。&lt;/p&gt;

&lt;h2 id=&quot;xdg&quot;&gt;XDG&lt;/h2&gt;

&lt;p&gt;根据&lt;a href=&quot;https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html&quot;&gt;XDG Base Directory Specification&lt;/a&gt;，所有软件的配置文件应当放在 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.config&lt;/code&gt; 下面，但是实际上很多软件并没有遵守这个规定。这也是很多用户的 &lt;code class=&quot;highlighter-rouge&quot;&gt;~&lt;/code&gt; 目录下堆满了 dotfiles 的原因。&lt;/p&gt;

&lt;p&gt;不过这件事用户做不了主，这是程序员的责任。&lt;/p&gt;

&lt;p&gt;现在越来越多的软件开始遵守这个协定了，因此如果哪天找不到某个软件在 &lt;code class=&quot;highlighter-rouge&quot;&gt;~&lt;/code&gt; 下面的配置文件了，也许就在 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.config&lt;/code&gt; 下面。&lt;/p&gt;

&lt;h1 id=&quot;后记&quot;&gt;后记&lt;/h1&gt;

&lt;p&gt;在使用 Linux 后，我才深切地感受到「工具」本身是如何改变人的思维的。我们都能认识到，先有想法，再去通过工具去实现想法，但是「工具改变想法」这一点常被人忽略。可能这就是学习新工具的真正意义所在吧。&lt;/p&gt;
</description>
        <pubDate>Mon, 01 Apr 2019 00:00:00 -0400</pubDate>
        <link>http://yilin-zhang.github.io/off-topic/2019/04/01/off-topic-how-to-manage-files.html</link>
        <guid isPermaLink="true">http://yilin-zhang.github.io/off-topic/2019/04/01/off-topic-how-to-manage-files.html</guid>
        
        <category>Linux</category>
        
        <category>文件管理</category>
        
        
        <category>Off-topic</category>
        
      </item>
    
      <item>
        <title>Linux生存指南05 | 基础生存篇 | 包管理</title>
        <description>&lt;h1 id=&quot;有关命令行&quot;&gt;有关命令行&lt;/h1&gt;

&lt;p&gt;在原本的计划中，自己是打算写有关命令行的内容的，但是想到已有的很多资源都可以帮助到大家，自己再写一遍实在没有必要，而且也肯定不比优秀的教程出色；再者为了Linux的日常使用，只需要掌握基础的几个命令即可，没有必要花费整个章节去写，因此就放弃了这个想法。&lt;/p&gt;

&lt;p&gt;我写博客的目标是站在初学者的角度，分享这大半年来使用Linux的经验。初学者往往会遇到类似的问题，而这些微妙的疑惑又经常被写教程的高手忽略，所以我希望自己的写作能把对初学者有特殊价值的经验分享出来。同时我也想表明，如果某些内容我不了解，而又有现成的学习资源，我不会做无谓的重复劳动，但会尽力把自己了解到的资源分享给大家，让大家共同学习。&lt;/p&gt;

&lt;p&gt;有关命令行的知识，推荐一个叫做《The Linux Command Line》的很棒的教程，有&lt;a href=&quot;http://linuxcommand.org/tlcl.php&quot;&gt;英文原版&lt;/a&gt;和&lt;a href=&quot;https://www.kancloud.cn/thinkphp/linux-command-line&quot;&gt;中文版&lt;/a&gt;。推荐看前面几章了解文件查看、目录跳转、复制移动等基础操作即可，剩下的今后有需要再来看。这部教程涵盖了与命令行相关的方方面面，连如何编译程序都有介绍，非常实用。说实话我自己也没有看完，因为就算看完很多知识也会马上遗忘。最好的方法应该是在用中学。在介绍下面的内容之前，希望大家先把上面提到的教程的前几章看一看，熟悉一下命令行。&lt;/p&gt;

&lt;p&gt;「命令行超酷的！」&lt;/p&gt;

&lt;h1 id=&quot;为什么需要包管理&quot;&gt;为什么需要包管理&lt;/h1&gt;

&lt;p&gt;不过这一篇的内容是包管理。说起这个话题，很多对此有些了解的小伙伴马上想到了一个命令—— &lt;code class=&quot;highlighter-rouge&quot;&gt;apt-get&lt;/code&gt; ：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt-get &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;xxxx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;真方便！你想要的软件就这样装上了！&lt;/p&gt;

&lt;p&gt;但是这背后发生了什么呢？&lt;/p&gt;

&lt;p&gt;记得之前在 &lt;strong&gt;Linux简介&lt;/strong&gt; 一篇中提到过「软件仓库」这个词。软件仓库是什么？为什么需要软件仓库？&lt;/p&gt;

&lt;p&gt;回想起用 Windows 的时候，软件的安装包一般是直接从软件提供者获得的，你需要在下载后双击打开，完成安装程序。而 Linux 却很不相同，大多数你需要的软件都在发行版所提供的官方软件仓库中，并通过包管理工具完成下载和安装的操作。&lt;/p&gt;

&lt;p&gt;「软件仓库」的英文名是 repository ，也常被简称为 repo 。它的存在与 Linux 的开源软件生态有很大关系。Linux 操作系统是由世界各地的开发者共同协作完成的，在这种开发模式下，由于不像商业公司那样有能力做统一的管理，软件包之间的关系就显得相对松散了。假设今天开发者 A 想开发一款 Linux 下的音乐播放器，他当然不会去实现底层有关音频 IO 的代码，而开发者 B 已经实现了 A 所需要的组件，那么显然 A 会去使用 B 提供的组件。而开发者 B 为了实现自己的功能，可能需要更底层的组件，这时也许会使用开发者 C 提供的组件。开发者 A 当然还要开发图形界面，那还得用图形界面框架，图形界面框架也还依赖更底层的 X Window ……像这样一级一级依赖，就会形成一颗巨大的依赖树。Linux 发行版的存在，主要原因就是为了解决复杂的依赖关系。想象一下，如果操作系统的所有组件都需要自己一点点去找，还要在保证依赖关系（比如有些软件包依赖特定软件包的特定版本）的情况下，搭建起整个可用的操作系统，这样的工作量想想就觉得可怕。而 Linux 发行版通过从软件提供者手中获得软件并打包的方式，将绝大部分用户所需的软件放入其软件仓库，让用户可以轻松便捷地使用操作系统。&lt;/p&gt;

&lt;p&gt;你可能会问，为什么 Windows 就没有类似的问题呢？那是因为微软作为商业公司，已经帮开发者完成了操作系统很多的依赖组件了，因此软件的开发和使用才会如此无痛。而 Linux 的依赖问题总是被人诟病，甚至出现了一个词叫做 &lt;a href=&quot;https://en.wikipedia.org/wiki/Dependency%5Fhell&quot;&gt;dependency hell&lt;/a&gt; ，拿来形容操作系统的依赖关系无法满足时引发的令人炸毛的问题。&lt;/p&gt;

&lt;p&gt;当然，解决办法总是有的。Linux 发行版已经为用户做了很多工作，比如 package maintainers 会负责检查并打包上游的软件包，标注好所需的依赖软件名称和版本号，以及和它冲突的软件名称等等。发行版也会让自己软件仓库中的软件满足好依赖关系。有了这些信息，满足用户系统上的依赖性问题无非是一个算法问题。当然这个问题不该由用户来做，而是让一个更加自动化的管理工具来完成，这就是「包管理器」。&lt;/p&gt;

&lt;p&gt;Ubuntu 使用的包管理器是 APT ，实际上它也是 Debian 的包管理器（所有基于 Debian 的发行版都使用 APT 作为包管理器）。它的作用是帮助用户将本地软件包的信息与发行版软件仓库进行同步，下载、安装用户指定的软件，协助解决依赖足问题等等。我们可以把软件管理的任务统统交给包管理器解决，这样生活就轻松多了！&lt;/p&gt;

&lt;h1 id=&quot;apt之超级牛力&quot;&gt;APT之超级牛力&lt;/h1&gt;

&lt;h2 id=&quot;安装卸载和搜索包&quot;&gt;安装、卸载和搜索包&lt;/h2&gt;

&lt;p&gt;在命令行输入 &lt;code class=&quot;highlighter-rouge&quot;&gt;apt&lt;/code&gt; ，按回车。&lt;/p&gt;

&lt;p&gt;我是不是不用往下讲了！？重要的命令全在这里！&lt;/p&gt;

&lt;p&gt;注意到最后一句话：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;本 APT 具有超级牛力。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个可是真的，处理好这么多软件包的依赖关系可不是容易的事情。我当前的系统有三千多个软件包，全部都被 APT 管理得井井有条。&lt;/p&gt;

&lt;p&gt;不过 &lt;code class=&quot;highlighter-rouge&quot;&gt;apt&lt;/code&gt; 与 APT 并不是一回事。APT 的全称是（Advanced Package Tool），实际上是用于管理 Debian 软件包的一系列工具。我们以前常用的 &lt;code class=&quot;highlighter-rouge&quot;&gt;apt-get&lt;/code&gt; 是其中的工具之一。但以前的包管理工具对用户而言不太友好，因为用户常使用的命令分散在几个不同的工具中（比如用 &lt;code class=&quot;highlighter-rouge&quot;&gt;apt-get&lt;/code&gt; 安装和卸载软件包，用 &lt;code class=&quot;highlighter-rouge&quot;&gt;apt-cache&lt;/code&gt; 搜索和查看软件包信息），而一个统一的命令会让用户的使用更方便，这就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;apt&lt;/code&gt; 出现的原因。 &lt;code class=&quot;highlighter-rouge&quot;&gt;apt&lt;/code&gt; 相比上述的两个工具还多了彩色进度条输出和细节提示，增强了用户体验，所以建议大家今后尽量使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;apt&lt;/code&gt; 而不是 &lt;code class=&quot;highlighter-rouge&quot;&gt;apt-get&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;apt-cache&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;那这么多包管理工具在一起不会打架么？实际上并不会，因为他们都属于「高层包管理器」，而实际用于安装、卸载软件包，反馈依赖关系是否满足的，是「中层包管理器」dpkg。也就是说，高层包管理器只是负责协助用户与软件仓库同步软件包信息，下载安装用户指定的软件包，计算出需要的依赖包并且一并下载安装等等任务，为用户提供了一套方便的交互前端。有「中层」那就一定有「底层」，这个底层就是 dpkg-deb ，只是用于查看软件包的控制信息和抽取软件包中的文件。&lt;/p&gt;

&lt;p&gt;由于软件包需要安装在系统目录下，因此与包管理相关的操作（除了读取外）都需要 root 权限。&lt;/p&gt;

&lt;p&gt;在安装包前，一般需要与仓库同步软件包信息：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt update
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;安装包命令：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &amp;lt;package name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;卸载包命令：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt remove &amp;lt;package name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;默认在卸载时不会删除包的配置文件信息，如果需要删除，在最后面加上 &lt;code class=&quot;highlighter-rouge&quot;&gt;--purge&lt;/code&gt; 参数即可。&lt;/p&gt;

&lt;p&gt;搜索包：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apt search &amp;lt;package name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因为搜索只是做了读取操作，因此不需要 root 权限。&lt;/p&gt;

&lt;h2 id=&quot;自动安装手动安装和孤儿包&quot;&gt;自动安装、手动安装和孤儿包&lt;/h2&gt;

&lt;p&gt;自动安装的包和手动安装的包待遇是不同的。&lt;/p&gt;

&lt;p&gt;手动安装的包就是用户指定安装的包，比如我想安装的记词软件 Anki ，那么我指定安装的软件包就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;anki&lt;/code&gt; ，而 APT 通过解析发现还需要图形库 &lt;code class=&quot;highlighter-rouge&quot;&gt;python-pyqt5&lt;/code&gt; ，并将其自动安装，那么 &lt;code class=&quot;highlighter-rouge&quot;&gt;python-pyqt5&lt;/code&gt; 就是自动安装的软件包。&lt;/p&gt;

&lt;p&gt;有什么区别呢？&lt;/p&gt;

&lt;p&gt;如果我删除了 &lt;code class=&quot;highlighter-rouge&quot;&gt;anki&lt;/code&gt; ，那么包管理器会认为既然 &lt;code class=&quot;highlighter-rouge&quot;&gt;python-pyqt5&lt;/code&gt; 这个包是自动安装的，现在也不被任何手动安装的软件包依赖（当然实际有可能其他手动安装的软件包也依赖于它，这里只是假设），那么它就是一个「孤儿包」。（就好比 &lt;code class=&quot;highlighter-rouge&quot;&gt;anki&lt;/code&gt; 生下了 &lt;code class=&quot;highlighter-rouge&quot;&gt;python-pyqt5&lt;/code&gt; ，现在 &lt;code class=&quot;highlighter-rouge&quot;&gt;anki&lt;/code&gt; 走了，而且没人要 &lt;code class=&quot;highlighter-rouge&quot;&gt;python-pyqt5&lt;/code&gt; ，它就成了孤儿。）包管理器会自动提示用户， &lt;code class=&quot;highlighter-rouge&quot;&gt;python-pyqt5&lt;/code&gt; 是自动下载且不被任何软件包需要，可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;apt autoremove&lt;/code&gt; 进行删除。&lt;/p&gt;

&lt;p&gt;所以可以通过下面的命令删除当前所有的孤儿包：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt autoremove
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果想删除配置文件，一样可以在后面加上 &lt;code class=&quot;highlighter-rouge&quot;&gt;--purge&lt;/code&gt; 参数。&lt;/p&gt;

&lt;p&gt;一般来说，如果包管理器提示可以自动删除某些包，删除就是了，要不然会一直提示用户非常烦人，而且像我这样有些洁癖的人来说，孤儿包的存在是不可容忍的！&lt;/p&gt;

&lt;p&gt;但是还是要小心，因为我在网上看到很多人因为自己删了某个软件包，导致自己的桌面环境也被当做孤儿包被删了（我倒是没有遇到这个情况，因为我使用的操作系统已经默认将桌面环境相关的包标记为手动安装）。我觉得很有可能是发行版打包的失误，或者用户动了某个不该动的元包（meta package，依赖于一系列包的软件包，也就是说安装一个元包就可以自动安装一系列相关的包，例如桌面环境的元包）。总之在 &lt;code class=&quot;highlighter-rouge&quot;&gt;autoremove&lt;/code&gt; 前瞄一眼就行了，不过出现这种情况的概率实在太低太低了，而且即便真的删了桌面环境，照样能装回来！&lt;/p&gt;

&lt;p&gt;还有一种情况和孤儿包无关，那就是手动删除了某个依赖包时，包管理器会自动删除依赖这个包的软件包，也就是说如果我删除了 &lt;code class=&quot;highlighter-rouge&quot;&gt;python-pyqt5&lt;/code&gt; ，也会自动把 &lt;code class=&quot;highlighter-rouge&quot;&gt;anki&lt;/code&gt; 删除掉。&lt;/p&gt;

&lt;p&gt;虽说会有出现意外的可能，但只要用户正常操作，这种情况完全能够避免。&lt;/p&gt;

&lt;h2 id=&quot;包从哪里来&quot;&gt;包从哪里来&lt;/h2&gt;

&lt;h3 id=&quot;本地包&quot;&gt;本地包&lt;/h3&gt;

&lt;p&gt;之前已经提到过，发行版会将上游的软件打包并纳入自己的仓库中。但是依然有两个问题存在：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Debian 系发行版一般采用的是 point release ，也就是每隔一段时间发布一个大版本，而在大版本中的软件包是已经经过一段时间的测试并确认稳定的，因此软件仓库的包普遍偏旧，无法满足用户使用新包的要求；&lt;/li&gt;
  &lt;li&gt;有些软件根本没有纳入发行版的软件仓库中（压根没有被发行版打包），无法满足用户使用该软件的要求。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种情况下该怎么办呢？一个最容易想到的方法就是，直接去软件提供方找。在开源生态下，软件作者起码会提供源代码，能让用户自己编译安装。不过多数软件作者都会提供自行打包好的软件包，这样用户就可以把软件包下载到本地，并直接安装编译好的软件包了，而且由于是一个打包好的软件包，还能被包管理器所控制。&lt;/p&gt;

&lt;p&gt;Debian 的软件包格式是 deb ，你下载的 &lt;code class=&quot;highlighter-rouge&quot;&gt;.deb&lt;/code&gt; 文件就是软件包了。实际上打包的方法非常简单，有兴趣的小伙伴可以去 &lt;a href=&quot;https://wiki.debian.org/Packaging&quot;&gt;Debian Wiki&lt;/a&gt; 看一看！&lt;/p&gt;

&lt;p&gt;如何安装呢？在网上你经常会看到推荐这种方法：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;dpkg &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; &amp;lt;package name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;等一等！刚才说过，dpkg 是一个中层包管理器，并不负责帮用户「解决」依赖关系。也就是说，如果这个本地软件包需要的依赖包在系统中不存在，虽然 dpkg 会帮我们把软件装上，但它会标记为安装不完全，并且一直提醒用户有未满足的依赖关系。&lt;/p&gt;

&lt;p&gt;那该怎么办？在网上很多人会告诉你：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt-get &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;像之前说的，实际上这里的 &lt;code class=&quot;highlighter-rouge&quot;&gt;apt-get&lt;/code&gt; 可以被 &lt;code class=&quot;highlighter-rouge&quot;&gt;apt&lt;/code&gt; 代替了。那么这行命令的作用是什么呢？重点是最后一个参数 &lt;code class=&quot;highlighter-rouge&quot;&gt;-f&lt;/code&gt; ，它是 &lt;code class=&quot;highlighter-rouge&quot;&gt;--fix-broken&lt;/code&gt; 的简写，顾名思义就是修复损坏的依赖关系。APT 会帮助我们在仓库中搜索对应的依赖包，并把它们装上。（如果依赖包并不在仓库里就比较麻烦了，不过一般不会出现这种情况。）&lt;/p&gt;

&lt;p&gt;可是这样不是绕了一个弯子吗？何不直接让 APT 帮我们安装本地软件包，顺便也帮我们装好依赖包，这样多好！&lt;/p&gt;

&lt;p&gt;方法也真的很简单，只是比较少的人提到：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &amp;lt;package path&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意最后那个参数是 &lt;strong&gt;本地软件包的路径&lt;/strong&gt; ，举个例子：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; ./lsd_0.13.0_amd64.deb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它安装的是当前目录下的 &lt;code class=&quot;highlighter-rouge&quot;&gt;lsd_0.13.0_amd64.deb&lt;/code&gt; 软件包，别漏了 &lt;code class=&quot;highlighter-rouge&quot;&gt;./&lt;/code&gt; 来表示当前目录，要不然它会去仓库中找软件包，而不是本地。也别忘了后缀名 &lt;code class=&quot;highlighter-rouge&quot;&gt;.deb&lt;/code&gt; 。Linux 并不靠后缀名来区分文件类型，基本它的后缀名是 &lt;code class=&quot;highlighter-rouge&quot;&gt;.txt&lt;/code&gt; 一样可以是个 deb 包。后缀名的作用主要是帮助用户识别不同的文件类型而已。&lt;/p&gt;

&lt;p&gt;当然你的系统可能也已经自带了「GDebi软件包安装程序」 ，这是一个图形界面前端，能让用户鼠标双击软件包轻松安装软件。&lt;/p&gt;

&lt;h3 id=&quot;仓库和ppa&quot;&gt;仓库和PPA&lt;/h3&gt;

&lt;p&gt;但是这样还是太麻烦了，如果软件包有更新，用户还要自己去软件作者那里获得新版本重新安装。有没有更简单的办法呢？&lt;/p&gt;

&lt;p&gt;有的！那就是第三方软件仓库。任何人都可以搭建自己的软件仓库， Debian 和 Ubuntu 也从来没有限制这么做（Ubuntu 甚至提供了一个更便捷的平台）。&lt;/p&gt;

&lt;p&gt;比如我想安装一个 Windows 应用的兼容层 WINE （让用户可以运行 Windows 程序），我会选择去 &lt;a href=&quot;https://wiki.winehq.org/Download%5Fzhcn&quot;&gt;WINE 的官方网站&lt;/a&gt;找到对应的发行版的&lt;a href=&quot;https://wiki.winehq.org/Ubuntu%5Fzhcn&quot;&gt;安装指南&lt;/a&gt;，并一步步进行操作。主要会经历以下几个步骤：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;添加仓库密钥&lt;/li&gt;
  &lt;li&gt;添加仓库&lt;/li&gt;
  &lt;li&gt;更新软件包信息&lt;/li&gt;
  &lt;li&gt;安装软件包&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实际上并不复杂不是吗！但作为软件作者，自行搭建一个软件仓库还是有些麻烦，所以 Ubuntu 提供了一个平台叫做 PPA（Personal Package Archives），软件作者可以免费将软件打包并发布在 PPA 上面。本质上 PPA 也是一个软件仓库。&lt;/p&gt;

&lt;p&gt;比如说一个月前自己想使用 Emacs 26 ，而 Ubuntu 仓库中的 Emacs 版本是25。后来我选择了一个 PPA ，它的维护者将最新的稳定版 Emacs 打包上传（即便他不是软件作者也可以打包上传，毕竟 Emacs 是自由软件），我只需要加入 PPA 信息，安装软件即可（ &lt;code class=&quot;highlighter-rouge&quot;&gt;add-apt-repository&lt;/code&gt; 已经把添加秘钥的工作做好了，所以不需要用户操心）：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;add-apt-repository ppa:kelleyk/emacs
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt update
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;emacs26
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;那么如何删除与软件仓库的连接呢？Ubuntu 预装了一个 GUI 工具叫做「软件和更新」，打开后在「其它软件」标签下就可以看到所有连接到的仓库了，想删除的话直接选中，点击「删除」就行了。&lt;/p&gt;

&lt;p&gt;实际上这个 GUI 工具做了什么事呢？&lt;/p&gt;

&lt;p&gt;所有与软件仓库有关的信息都存放在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/apt&lt;/code&gt; 目录下面，其中 PPA 以外的软件仓库信息写在 &lt;code class=&quot;highlighter-rouge&quot;&gt;sources.list&lt;/code&gt; 文件中，与 PPA 相关的信息在 &lt;code class=&quot;highlighter-rouge&quot;&gt;sources.list.d&lt;/code&gt; 目录下，一般一个 PPA 的信息会单独写在这个目录的一个文件当中。另外，PPA 以外的仓库的秘钥信息存放在 &lt;code class=&quot;highlighter-rouge&quot;&gt;trusted.gpg&lt;/code&gt; 文件中，PPA 的秘钥信息在 &lt;code class=&quot;highlighter-rouge&quot;&gt;trusted.gpg.d&lt;/code&gt; 目录下。&lt;/p&gt;

&lt;p&gt;如果你只是想暂停使用某个仓库（在 GUI 工具中把对应仓库前的勾取消掉），那只是会把 &lt;code class=&quot;highlighter-rouge&quot;&gt;souces.list&lt;/code&gt; 中或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;sources.list.d&lt;/code&gt; 目录下与该仓库相关的信息注释掉，而秘钥当然不会删除；但如果你在 GUI 工具中删除某个仓库，实际上它也只是把对应写有仓库信息的文件中的相关几行删除，秘钥也不会删除。&lt;/p&gt;

&lt;p&gt;如果你没有洁癖，实际上也无所谓，如果真的想完全删除干净，那直接去那个目录把文件删除就可以了，只不过也没有什么必要。&lt;/p&gt;

&lt;p&gt;除了用 GUI 工具外，使用命令行当然是可以的。有下面几种方法可以选择：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;add-apt-repository&lt;/code&gt; 删除软件仓库，但是它不会删除用该 PPA 安装的软件，以删除上面提到的 Emacs 仓库为例：&lt;/p&gt;

    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;add-apt-repository &lt;span class=&quot;nt&quot;&gt;--remove&lt;/span&gt; ppa:kelleyk/emacs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;要删除非 PPA 仓库也一样，只要在添加仓库的命令上加入 &lt;code class=&quot;highlighter-rouge&quot;&gt;--remove&lt;/code&gt; 参数就行了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一个好的选择使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;ppa-purge&lt;/code&gt; ，它不但能删除 PPA ，也能删除用这个 ppa 安装的软件，并且如果同样的在官方仓库，会换成官方仓库的版本：&lt;/p&gt;

    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ppa-purge ppa:kelleyk/emacs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;去除密钥可以使用命令 &lt;code class=&quot;highlighter-rouge&quot;&gt;apt-key del xxx&lt;/code&gt; ，其中 &lt;code class=&quot;highlighter-rouge&quot;&gt;xxx&lt;/code&gt; 是用 &lt;code class=&quot;highlighter-rouge&quot;&gt;apt-key list&lt;/code&gt; 查到的密钥的16进制后8位。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意删除文件可以在命令 &lt;code class=&quot;highlighter-rouge&quot;&gt;rm&lt;/code&gt; 后加上 &lt;code class=&quot;highlighter-rouge&quot;&gt;-i&lt;/code&gt; 参数交互式删除，避免误删。&lt;/p&gt;

&lt;h2 id=&quot;手动解决依赖问题&quot;&gt;手动解决依赖问题&lt;/h2&gt;

&lt;p&gt;这种情况一般出现在自行编译安装软件的时候。比如说在运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;configure&lt;/code&gt; 的时候说缺少某个 &lt;code class=&quot;highlighter-rouge&quot;&gt;.h&lt;/code&gt; 头文件。&lt;/p&gt;

&lt;p&gt;首先，软件作者很可能已经给出了所需要的依赖包，去软件仓库找到这些包安装就行了。但很多时候软件作者没有给这些信息，那该怎么办？除了上网搜索有没有其他人遇到同样的问题之外，还有一个方法是使用一个叫做 &lt;code class=&quot;highlighter-rouge&quot;&gt;apt-file&lt;/code&gt; 的命令行工具，不过这个工具 Ubuntu 并没有预装，得自己额外安装。&lt;/p&gt;

&lt;p&gt;如何使用呢？直接用 &lt;code class=&quot;highlighter-rouge&quot;&gt;apt-file --help&lt;/code&gt; 看一下就行了。说明的最后一段提到：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Action:
    update                              Fetch Contents files from apt-sources.
    search|find        &lt;pattern&gt;        Search files in packages
    list|show          &lt;pattern&gt;        List files in packages&lt;/pattern&gt;&lt;/pattern&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于我们提出的问题，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;search&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;find&lt;/code&gt; 就行了：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apt-file search &amp;lt;file name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果已知所缺文件的准确路径，传入整个路径就行了。 &lt;code class=&quot;highlighter-rouge&quot;&gt;apt-file&lt;/code&gt; 会帮我们返回所有包含这个文件的软件包，把对应软件包装上就可以了。&lt;/p&gt;

&lt;h1 id=&quot;synaptic&quot;&gt;Synaptic&lt;/h1&gt;

&lt;p&gt;APT 工具的命令确实有点多，要是记不住也问题不大，因为有一个非常好用的 GUI 前端工具叫做 Synaptic，中文叫「新立得软件包管理器」（这个翻译不错！）。&lt;/p&gt;

&lt;p&gt;使用方法很简单，你打开来就会用了。这个软件在打开时就需要输入 root 密码提升权限，在整个操作过程中都是有管理员权限的，所以操作得小心。&lt;/p&gt;

&lt;p&gt;我觉得 Synaptic 奇妙的地方在于，你会发现原来所不知道的 APT 具有的功能，明白原来 APT 真的在管理一切和软件包相关的事情。它知道你装了哪些本地包，各种包的文件放在了哪些目录，哪些被删除的包的配置文件还被保留，软件来源是哪里等等。所以有了 APT 后就完全不需要担心系统中的软件一团糟了。&lt;/p&gt;

&lt;h1 id=&quot;别弄乱系统目录&quot;&gt;别弄乱系统目录&lt;/h1&gt;

&lt;h2 id=&quot;编译安装&quot;&gt;编译安装&lt;/h2&gt;

&lt;p&gt;对于想长期使用 Linux 的用户来说，管理好系统目录是很重要的一件事情。比如今天你通过编译安装的方式安装了某个软件，那么它虽然把文件放在了系统目录下，但却因为绕过了 APT 而无法被其管理。&lt;/p&gt;

&lt;p&gt;举一个简单的例子，如果你昨天通过编译安装的方式安装了一个软件 A ，绕过了 APT 的管理，第二天想要更新系统，恰好也需要安装一个打包好的软件包 A ，由于 APT 并不知情，它不会略过这个软件包的安装。结果可想而知，由于先前编译安装时已经将软件的文件放在特定目录下，APT 会报错说文件冲突，无法安装软件包。这种情况尤其可能会在 point release 的大版本更新时出现，而且具体情况可能复杂得多。&lt;/p&gt;

&lt;p&gt;如果你并不关心更新，那么如果你想删除呢？很多软件并不提供卸载软件的脚本，如果你是通过编译安装的方式安装，很可能会因为不清楚软件安装时把文件放在了哪里而无法卸载。&lt;/p&gt;

&lt;p&gt;有什么好办法能解决这个问题呢？下面给出我个人的看法。&lt;/p&gt;

&lt;p&gt;首先，能不编译安装就不编译安装，因为普通用户确实用不到很多编译的参数，编译安装还容易踩很多不必要的坑，而且直接使用打包好的软件包是最方便的方式。而如果某些情况下一定要编译安装，我会推荐一个命令行工具叫做 &lt;code class=&quot;highlighter-rouge&quot;&gt;checkinstall&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;checkinstall&lt;/code&gt; 的功能是跟踪这个命令后的命令释放文件的路径，并打包成当前系统所使用的软件包格式。使用方法很简单，在它后面跟任何的安装命令都 ok 。&lt;a href=&quot;https://wiki.debian.org/CheckInstall&quot;&gt;Debian Wiki&lt;/a&gt; 上有这个工具的说明，如果想要查看详细文档可以去&lt;a href=&quot;http://checkinstall.izto.org/&quot;&gt;CheckInstall 的主页&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;从个人使用经验来看，最好像 Debian Wiki 中提到的那样，加入 &lt;code class=&quot;highlighter-rouge&quot;&gt;--install=no&lt;/code&gt; 这个参数，先打包再安装。否则如果先安装再打包，可能会因为在打包阶段填写控制信息出错而无法生成软件包的情况，这样就要去系统文件夹手动删除已经释放的文件了。不过也不用太担心，因为在释放阶段已经详细输出了已经释放的文件的路径，所以不会找不到哪些文件。&lt;/p&gt;

&lt;p&gt;总之，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;checkinstall&lt;/code&gt; 就能将编译安装的软件通过打包的方式纳入 APT 的管理范围，这样就不怕出问题了！&lt;/p&gt;

&lt;h2 id=&quot;多个包管理器&quot;&gt;多个包管理器&lt;/h2&gt;

&lt;p&gt;除了编译安装外，也有其它弄乱系统目录的可能。以大家熟悉的 Python 做例子。可能大家会使用 Python 的包管理器 PyPI （也就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;pip&lt;/code&gt; ）来安装 Python 的第三方库。但是容易出问题的事情是，很多人会使用系统的 Python 环境跑自己的代码（非软件开发性质的），并用 PyPI 安装自己想要的第三方库。这是不推荐的做法，因为 PyPI 的包管理绕过了管理系统软件包的 APT 。正确的做法是什么呢？如果想做软件开发，尽量使用软件仓库的软件包（deb 包），如果做科学计算等任务，最好使用一套与系统 Python 环境隔离的环境，比如 Anaconda 。前一种做法保证了 Python 库文件纳入 APT 的管理范围，后一种做法干脆就把 Python 环境放在用户目录下，与系统软件包不相干，这样最省事了。&lt;/p&gt;

&lt;p&gt;可能出现类似情况的还有 Node.js 的包管理器 npm 。不过由于 &lt;code class=&quot;highlighter-rouge&quot;&gt;nodejs&lt;/code&gt; 并不是系统自带的软件包，因此出现包管理冲突的可能性不大，不过最好还是不要用 npm 把全局包装在系统目录下，也就是避免使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo npm install &amp;lt;package name&amp;gt; -g&lt;/code&gt; 。我的解决方法是在用户目录下的 &lt;code class=&quot;highlighter-rouge&quot;&gt;.bashrc&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;.profile&lt;/code&gt; 添加如下两行：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;NPM_CONFIG_PREFIX&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$HOME&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/.npm-global&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;PATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$HOME&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/.npm-global/bin:&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$PATH&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&quot;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;第一行告诉 npm 将全局包装在 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.npm-global&lt;/code&gt; 下，第二行将 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.npm-global&lt;/code&gt; 这个路径加入环境变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;PATH&lt;/code&gt; 。我参考的是&lt;a href=&quot;https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally&quot;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;

&lt;h1 id=&quot;谨慎使用第三方仓库&quot;&gt;谨慎使用第三方仓库&lt;/h1&gt;

&lt;p&gt;第三方仓库终究只是第三方仓库，没有发行版的背书，不能保证软件的安全性和稳定性。因此作为用户，首先要甄别这个第三方仓库是否是值得信赖的仓库，否则出了问题可没人能负责。&lt;/p&gt;

&lt;h1 id=&quot;snapflatpak和appimage&quot;&gt;Snap，Flatpak和Appimage&lt;/h1&gt;

&lt;p&gt;Linux 世界不只有 Debian 系发行版，还有 Redhat 系，Arch 系等等，各自使用不同的包管理机制，软件包的打包格式也不相同。对于软件开发者来说，这是一件比较头疼的事情，因为他们需要把自己的软件打包成各种各样的格式，来满足不同 Linux 发行版的需要。作为 Debian 系操作系统用户，一个福利是 deb 包的官方软件仓库是全宇宙最大的，而且多数软件都会优先提供 deb 包，但是对其他发行版用户来说就不是这么回事了（不过 Arch 用户有个 AUR 倒是很方便，软件总量也许加起来比 Debian 系的还多）。&lt;/p&gt;

&lt;p&gt;对于这种分裂，一种可行的解决方案是，把软件本身所需要的依赖打成一个包，并把它放在一个相对隔离的环境下运行，做到一次发布，所有发行版都可使用的效果。&lt;/p&gt;

&lt;p&gt;Snap，Flatpak和Appimage就是这种解决方案的三种实现。Snap 主要是 Canonical 在推，而 Flatpak 主要是 Redhat 在推。这三种实现的原理我并不了解，所以也没有办法和大家解释清楚。从表面上看，Snap 和 Flatpak 比较相似，而这两个中我只用过 Snap （因为 Ubuntu 自带 Snap）。Snap 看上去是在系统中划出了许多个虚拟的分区，你可以用 &lt;code class=&quot;highlighter-rouge&quot;&gt;lsblk&lt;/code&gt; 命令看到这些分区的存在。它为每一个 Snap 应用划分一个虚拟分区作为容器，将应用程序放在这个容器中。&lt;/p&gt;

&lt;p&gt;Appimage 的实现方式有所不同。它是这三者中最简单的。你在运行 Appimage 前什么都不用做，不像 Snap 或者 Flatpak 还需要额外安装一个使用框架，你只需要获得一个 Appimage 可执行文件就行了，打开就能使用。所以这三个中，Appimage 是我最喜欢的一种。&lt;/p&gt;

&lt;p&gt;Flatpak 由于自己没有使用过，没有经验可以分享。而 Snap 我个人并不推荐，主要有几个原因：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;服务器在国外，下载时连接速度非常慢；&lt;/li&gt;
  &lt;li&gt;用户与软件发行方直接关联，没有发行版的安全保障；&lt;/li&gt;
  &lt;li&gt;非自由软件生态；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我的看法是，deb &amp;gt; Appimage &amp;gt; Snap/Flatpak ，给大家参考。&lt;/p&gt;

&lt;h1 id=&quot;延伸阅读&quot;&gt;延伸阅读&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Dependency%5Fhell&quot;&gt;Dependency hell - Wikipedia&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://itsfoss.com/apt-vs-apt-get-difference/&quot;&gt;Difference Between apt and apt-get Explained - It’s FOSS&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wiki.debian.org/DebianPackageManagement&quot;&gt;DebianPackageManagement - Debian Wiki&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wiki.debian.org/dpkg&quot;&gt;dpkg - Debian Wiki&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wiki.debian.org/Packaging&quot;&gt;Packaging - Debian Wiki&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wiki.debian.org/CheckInstall&quot;&gt;CheckInstall - Debian Wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 09 Mar 2019 00:00:00 -0500</pubDate>
        <link>http://yilin-zhang.github.io/linux%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97/2019/03/09/linux-guide-05-package-management.html</link>
        <guid isPermaLink="true">http://yilin-zhang.github.io/linux%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97/2019/03/09/linux-guide-05-package-management.html</guid>
        
        <category>Linux</category>
        
        <category>Ubuntu</category>
        
        
        <category>Linux生存指南</category>
        
      </item>
    
      <item>
        <title>Linux生存指南04 | 基础生存篇 | 安装Ubuntu</title>
        <description>&lt;p&gt;终于到了安装Linux的时候了！不过在这里得先说明两点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;就像第2篇所说，这个系列博客面向Ubuntu用户，所以安装过程的介绍也是按照Ubuntu的安装流程走。不过现在大多数桌面发行版都提供了图形化安装界面，安装的流程也大同小异。所以如果你想安装其它发行版，也可以在这里得到一定的参考。&lt;/li&gt;
  &lt;li&gt;网络上有非常多关于Ubuntu安装的教程，因此在这里重复写并无意义。Ubuntu的安装程序也对用户非常友好，即便不看教程照样能顺利安装。所以这篇博客只提供一些安装过程中需要重点注意的内容。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么现在开始吧！&lt;/p&gt;

&lt;h1 id=&quot;确认硬件兼容性&quot;&gt;确认硬件兼容性&lt;/h1&gt;

&lt;p&gt;这是最要命的一点。即便当下Linux的硬件兼容已经比曾经好了很多，仍然远比不上Windows，毕竟后者才是最主流的操作系统，并且硬件厂商最先想到的还是做Windows的驱动。有些品牌的电脑对Linux的支持很好（比如Dell），而有些则不一定，有可能你电脑的某一个硬件（比如摄像头、触摸板、指纹识别等等）会无法正常工作。不过即便如此，大部分电脑都不会出现太大问题，只不过有些可能需要进行一定的配置调整。&lt;/p&gt;

&lt;p&gt;想知道自己的电脑硬件是否兼容Ubuntu，可以进入&lt;a href=&quot;https://certification.ubuntu.com/desktop/&quot;&gt;这个页面&lt;/a&gt;搜索自己电脑的型号。上述网页中列出的是Canonical的OEM合作伙伴提供预装Ubuntu的计算机信息，也就是说如果你的电脑型号出现在其中，那么一定能保证硬件兼容性（但是不保证Ubuntu和Windows双系统时不会出问题，比如我自己的Dell XPS13 9343在双系统时，声卡不能正常工作）。而如果你的电脑并不在其中，或者你想知道更多有关自己计算机的可能出现的问题，可以使用搜索引擎查一查相关的讨论和评价。推荐使用英文搜索（比如Bing），这样能够找到更多的信息。&lt;/p&gt;

&lt;p&gt;另外，大部分UEFI启动的计算机都会开启「secure boot」。它的本意是只允许经过签名授权的固件和驱动运行，帮助用户避免恶意程序的侵害。但是secure boot后来逐渐变成了微软的垄断工具。微软要求制造商，预装Windows 8的桌面计算机必须开启secure boot。虽然secure boot可以被用户关闭，但这样一来硬件厂商还是需要向微软付费以获得签名授权，让他们的硬件能使用secure boot启动。&lt;sup id=&quot;fnref:rod-smith&quot;&gt;&lt;a href=&quot;#fn:rod-smith&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;（现在的Windows 10 也默认开启secure boot。）然而，Linux中许多固件和驱动并未获得授权，因此开启secure boot可能导致某些硬件在Linux下无法正常工作&lt;sup id=&quot;fnref:is-it-safe&quot;&gt;&lt;a href=&quot;#fn:is-it-safe&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;，所以建议关闭secure boot再进入Linux。关闭secure boot一般不影响Windows的使用。微软官方也给出了&lt;a href=&quot;https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/disabling-secure-boot&quot;&gt;关闭secure boot的方法&lt;/a&gt;。&lt;/p&gt;

&lt;h1 id=&quot;iso映像文件&quot;&gt;iso映像文件&lt;/h1&gt;

&lt;h2 id=&quot;认识iso&quot;&gt;认识iso&lt;/h2&gt;

&lt;p&gt;一般发行版官方都会提供iso映像用于安装操作系统，Ubuntu也不例外。iso映像可以理解为将光盘上的内容未压缩地拷贝到一个二进制文件中。记得十多年前人们往往会使用光盘来安装操作系统。但是iso映像并不一定真的要刻录到光盘上才能使用，你可以将它写入其它外部存储设备，比如U盘或移动硬盘。而如果你只是想把它装到虚拟机上，直接让虚拟机的虚拟光驱读入这个iso文件就可以了。&lt;/p&gt;

&lt;h2 id=&quot;版本选择&quot;&gt;版本选择&lt;/h2&gt;

&lt;p&gt;具体有关版本选择的内容在第2篇已经详细介绍过了。当时的主要目的是让大家了解Ubuntu不同版本的含义和它版本迭代的机制，并推荐使用LTS版本。而这一节是关于一个细节的补充：32位和64位计算机的支持。&lt;strong&gt;如果你想把Ubuntu装在64位计算机上，可以跳过这一节。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Ubuntu标准版（也就是默认搭载GNOME 3桌面环境的那款）的最新LTS版本是Ubuntu 18.04LTS。Canonical已经放弃了该版本和其后版本中对32位计算机的支持，这是因为经用户调查后发现，当今使用32位计算机的用户占比极少。但如果你的确想把Ubuntu装在32位计算机上，你可以尝试Ubuntu的那些flavors。Lubuntu、Xubuntu、Ubuntu MATE、Ubuntu Budgie都提供18.04LTS的32位版本。如果你一定要安装标准版Ubuntu，还是有办法的，因为当前32位的软件仓库仍存在（要不然那些flavors怎么支持32位呢），具体方法可以参考&lt;a href=&quot;https://askubuntu.com/questions/1032727/how-to-download-a-32-bit-version-of-ubuntu-18-04&quot;&gt;Stack Exchange中这个问题的解答&lt;/a&gt;。但是这么做实在没有必要，而且由于没有官方的维护，出现的问题很可能得不到修复，因此非常不推荐。&lt;/p&gt;

&lt;p&gt;另外从18.10版本开始，这些flavors中除了Xubuntu和Lubuntu，都放弃了对64位计算机的支持。如果你确实想在旧电脑上使用Linux，来让老机器重获新生（当Windows把老爷机卡得欲仙欲死时，一款合适的Linux发行版可能让它箭步如飞），那当然没问题，再怎么样也总能找到支持32位计算机的Linux发行版。但是如果这是你的主力电脑……那真的可以考虑换新电脑啦！&lt;/p&gt;

&lt;h2 id=&quot;live操作系统&quot;&gt;Live操作系统&lt;/h2&gt;

&lt;p&gt;如果你有安装盗版Windows的经验，你可能听说过「PE系统」这种说法。你首先需要把这个所谓的「PE系统」写入到U盘或光盘上，然后在计算机启动前插入，调整启动顺序，让电脑通过这个外部存储设备启动，最后会来到一个操作系统界面。&lt;/p&gt;

&lt;p&gt;其实这个时候，你运行的是这个外设给你提供的操作系统。你可以使用这个操作系统中的安装程序来将操作系统安装到你的硬盘上，也可以使用它为了方便用户而提供的一系列软件，用于修改分区和修复bootloader等等。&lt;/p&gt;

&lt;p&gt;Ubuntu也是如此。当你将iso写入存储设备后，你就制作好了一个便携的，一般叫做「Live CD」或是「Live USB」（视你的存储设备是CD还是U盘而定）的东西。你可以像上面说的一样启动它，进入一个操作系统「一般叫做Live OS」。这个操作系统有什么用呢？下面列出了我认为比较重要的几个功能：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;安装操作系统。这也是这个Live OS最主要的功能。&lt;/li&gt;
  &lt;li&gt;体验操作系统。Live OS能让你在不真正安装这个操作系统的情况下体验它。你可以体验一下这个桌面环境，调整一下它的设置，或是打开火狐浏览器上个网。同时这也是一个机会，让你检查计算机上的各个硬件能否正常工作。&lt;/li&gt;
  &lt;li&gt;修复系统。有时你想要重新设置你的分区大小或挂载点，而在你计算机上的Linux运行时，不能将挂载在主要目录上的分区卸载，因此只能使用Live OS，在那些分区不被挂载的情况下修改它们。又或者你的操作系统因为bootloader损坏而无法启动，这时你可以用Live OS修复bootloader。&lt;/li&gt;
  &lt;li&gt;数据恢复。如果你计算机上的操作系统因为种种原因而无法启动，而你想要拿出硬盘中的一些文件该怎么办？你可以使用这个Live OS来帮助你。你只要将硬盘上的分区挂载到这个Live OS上，就可以看到其中的文件了。此时你可以插入另一个存储设备，将这些文件拷贝过去。Linux的Live OS的另一个好处是，因为它的虚拟文件系统支持非常多种文件系统，所以Windows的NTFS分区照样能够被挂载。也就是说你不仅能拿到硬盘上Linux分区中的数据，也可以拿到Windows的。（如果你使用双系统，你会发现Linux可以拿到Windows硬盘上的文件，而反过来则不行。）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因此，LiveCD/LiveUSB是你的朋友，它不仅可以帮助你安装操作系统，也能让你的系统多一层保障。我个人建议在LiveCD/LiveUSB制作完成后把它保留在身边，以备不时之需。这不是因为Linux容易挂掉所以需要经常重装，而只是让你在遇到概率很小的意外时有一根救命稻草。（如果你使用滚动更新的发行版，这种风险会比较大，但是使用Ubuntu，只要不在自己的掌控外折腾系统，就完全不需要担心。在后面我也会写一篇文章来介绍良好的系统维护的方法。）&lt;/p&gt;

&lt;p&gt;当然，如果自己只是想快速装好系统，你也可以不进入Live OS而直接开始安装。&lt;/p&gt;

&lt;h2 id=&quot;下载iso文件&quot;&gt;下载iso文件&lt;/h2&gt;

&lt;p&gt;有关下载iso文件，实际上也没什么好说明的，因为大家都知道去Ubuntu官方的&lt;a href=&quot;https://www.ubuntu.com/download/desktop&quot;&gt;下载页面&lt;/a&gt;下载。如果你想使用Ubuntu的其它flavors，可以&lt;a href=&quot;https://www.ubuntu.com/download/flavours&quot;&gt;在这里&lt;/a&gt;找到你喜欢的flavor。&lt;/p&gt;

&lt;p&gt;另外，由于Canonical的服务器架设在国外，下载速度会比较慢。可以考虑去&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/&quot;&gt;清华大学开源软件镜像站&lt;/a&gt;或是&lt;a href=&quot;http://mirrors.ustc.edu.cn/&quot;&gt;USTC open source software mirror&lt;/a&gt;下载iso文件。链接在网页的右侧。&lt;/p&gt;

&lt;h1 id=&quot;进入live操作系统&quot;&gt;进入Live操作系统&lt;/h1&gt;

&lt;h2 id=&quot;物理机&quot;&gt;物理机&lt;/h2&gt;

&lt;p&gt;物理机的安装流程可以在网上找到太多太多了。这里只给出为了进入Live OS需要经历的大致步骤：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果希望装双系统，需要腾出至少25GB未使用的硬盘空间，建议备份数据，以防万一。如果是单系统就更要备份数据了，毕竟整个硬盘都将会被格式化。&lt;/li&gt;
  &lt;li&gt;将iso文件写入外部存储器。一般推荐使用U盘，并使用一个叫&lt;a href=&quot;https://rufus.ie/&quot;&gt;Rufus&lt;/a&gt;的工具。&lt;/li&gt;
  &lt;li&gt;关机，将U盘插入USB口，启动电脑，进入BIOS或UEFI，将U盘启动优先级设置为最高。&lt;/li&gt;
  &lt;li&gt;语言选择「中文」，点击「试用Ubuntu」进入Live OS。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;注意，如果你不是选择「最小安装」（只预装必要的软件），会需要在安装时下载所需的软件包，因此需要保证安装时的网络连接。&lt;/strong&gt; 某些电脑的无线网卡驱动是专有驱动（比如我的电脑需要使用Broadcom的专有驱动），而这些专有驱动是不会包含在Live OS里的，所以你在安装过程中需要使用有线网络连接。不过系统在安装时会帮你下载安装专有驱动，所以等安装结束就可以正常使用无线网卡了。一般在Live OS中无法使用无线网络的计算机都是这种情况，因此要准备网线，并且如果你的电脑没有网线端口，还要准备一个扩展坞。&lt;/p&gt;

&lt;p&gt;在上一篇中提到，在手动分区前需要知道自己的计算机到底使用的是BIOS还是UEFI。如果你在进入Live OS后还是不知道自己到底使用的是哪一个，看看自己的Live OS有没有&lt;code class=&quot;highlighter-rouge&quot;&gt;/sys/firmware/efi&lt;/code&gt;这个目录。如果存在，那就是UEFI，否则就是BIOS。如果你并不需要手动分区，就无需关心这一点。&lt;/p&gt;

&lt;h2 id=&quot;虚拟机&quot;&gt;虚拟机&lt;/h2&gt;

&lt;p&gt;虚拟机安装过程要简单得多。我推荐使用VirtualBox而不是VMware，后者是需要付费的商业软件，而且前者的功能十分强大，足够用了。&lt;/p&gt;

&lt;p&gt;需要指出两点：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;VirtualBox默认采用BIOS，如果你想使用UEFI需要进行设置。（在「设置」&amp;gt;「系统」&amp;gt;「主板」&amp;gt;「扩展特性」中，勾上「启用EFI」。）&lt;/li&gt;
  &lt;li&gt;最小分配25G硬盘大小。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;分区&quot;&gt;分区&lt;/h1&gt;

&lt;p&gt;就像上一篇所说，如果你只是想体验和学习一下Linux，而不把它作为日常使用的操作系统，分区这一步可以忽略，否则还是非常建议手动做一下分区。&lt;/p&gt;

&lt;p&gt;在网上你可以找到很多分区的方式，但是大多数都没有解释清楚这样分区的原因，也有些分区方式已经过时，或者对桌面用户来说完全没有必要。&lt;/p&gt;

&lt;p&gt;对桌面用户而言，手动分区的主要目的是什么呢？就是将我们的&lt;code class=&quot;highlighter-rouge&quot;&gt;/home&lt;/code&gt;目录单独分区。这么做的好处就是当我们重装系统的时候，该目录的数据不会丢失，因为你无需格式化这个分区。不过还是非常建议大家重装系统前把数据备份好，以防意外发生。&lt;/p&gt;

&lt;p&gt;安装Ubuntu时，其中的一步就是询问用户的分区方式。默认选项是将Ubuntu和当前的操作系统并存（前提是你已经留出了足够的硬盘空间），还有一个选择是清除整个硬盘来安装Ubuntu，而手动分区的选项在最下面。&lt;/p&gt;

&lt;p&gt;选择了手动分区后，具体该怎么操作呢？你会进入一个窗口，让你修改分区。如果你想装单系统，那直接先清除所有分区，再一个个创建分区就行了，而如果你想装双系统，那可得小心，别把当前系统的分区给删除了！&lt;/p&gt;

&lt;p&gt;怎么分区呢？Arch Wiki的&lt;a href=&quot;https://wiki.archlinux.org/index.php/Partitioning&quot;&gt;Partitioning&lt;/a&gt;词条已经解释得非常详尽了，主要参考「Example layouts」这一节的内容。（说句题外话，Arch Wiki的大多数词条都有中文版，只不过有些和英文版比较同步，而有些很久没有更新了，所以尽量以英文版为准。Partitioning这个词条当前中英文相同，所以也可以看中文版本。）&lt;/p&gt;

&lt;h2 id=&quot;根分区和家分区&quot;&gt;根分区和家分区&lt;/h2&gt;

&lt;p&gt;最重要的分区是&lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;/home&lt;/code&gt;，一般只需要分这两个就可以了。&lt;/p&gt;

&lt;p&gt;根分区&lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;的大小个人建议按照Arch Wiki中建议的最大分区大小来分配（除非你的硬盘空间十分紧张，这时可考虑适当缩小），如果使用swap文件而非分区，则在此基础上加上swap文件的大小。这个分区不需要太大，因为虽然Linux的软件基本都装在该分区下（主要是&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr&lt;/code&gt;目录下），但是它们一般都不会很大（比Windows小得多）。&lt;strong&gt;但根分区&lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;一定要留够空间，因为如果其空间被占满，系统将无法启动。&lt;/strong&gt; （个人认为30~40GB就足够了，50GB显得太多。我当前在包含一个4GB的swap文件的情况下，只使用了23GB。）&lt;/p&gt;

&lt;p&gt;家分区&lt;code class=&quot;highlighter-rouge&quot;&gt;/home&lt;/code&gt;尽可能大。一般是将必要分区分完后，将所有剩余空间都分给&lt;code class=&quot;highlighter-rouge&quot;&gt;/home&lt;/code&gt;，因为这是存放个人文件的地方。（而且如果你要玩Steam游戏，也会装在&lt;code class=&quot;highlighter-rouge&quot;&gt;/home&lt;/code&gt;下面。）&lt;/p&gt;

&lt;h2 id=&quot;swap分区&quot;&gt;Swap分区&lt;/h2&gt;

&lt;p&gt;上面提到的swap分区和swap文件是什么？有什么用？&lt;/p&gt;

&lt;p&gt;Swap分区和swap文件可以统称为「swap space」，也就是「交换空间」。&lt;strong&gt;交换空间位于硬盘，它有两个作用，一是为虚拟内存（virtual memory）提供额外的空间，二是为系统的休眠（hibernation）功能提供可能。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有关虚拟内存的内容，其实可以花掉一整篇博客的篇幅来写。这里我们只需要简单地理解成：&lt;strong&gt;交换空间就是物理内存的扩充&lt;/strong&gt;。也就是当物理内存（RAM）不够用时，可以用交换空间来存储内存中暂时用不到的数据，释放物理内存空间。我们知道内存的存取速度比硬盘快得多，因此操作系统会尽可能优先使用物理内存。&lt;/p&gt;

&lt;p&gt;「休眠」与「挂起（suspend）」是两个概念。内存是一种易失性存储器，必须在上电的情况下才能储存数据，如果掉电则会丢失数据。我们平时会经常将笔记本电脑合上，这时系统的操作是「挂起」，内存不掉电。如果我们把电脑重新打开，它会迅速从挂起状态恢复。而如果我们让系统「休眠」，那么电脑会将物理内存中的数据转移到交换空间，然后让内存掉电。要将电脑从休眠状态唤醒时，内存上电，交换空间中的数据再重新转移回内存。显然，「休眠」的整个过程相比「挂起」需要更多的时间。并且我们可以从休眠的整个过程中发现：&lt;strong&gt;只有交换空间大于等于物理内存时，才能实现休眠。&lt;/strong&gt; 虽然在Arch Wiki中提到：「就算交换空间小于物理内存空间，仍有很大几率能成功休眠」&lt;sup id=&quot;fnref:arch-hibernation&quot;&gt;&lt;a href=&quot;#fn:arch-hibernation&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;，但是为了休眠功能的完整，还是推荐大于物理内存的交换空间。&lt;/p&gt;

&lt;p&gt;在&lt;a href=&quot;https://help.ubuntu.com/community/SwapFaq#How_much_swap_do_I_need.3F&quot;&gt;Ubuntu的社区帮助Wiki&lt;/a&gt;，有一张物理内存大小和建议的交换空间大小的对照表格，包括了不需要休眠和需要休眠两种情况，可以给大家作为参考。可以发现，为了实现休眠，建议交换空间大小略大于物理内存。此外，Arch Wiki的Partition词条中也有相关的建议&lt;sup id=&quot;fnref:arch-swap&quot;&gt;&lt;a href=&quot;#fn:arch-swap&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在拥有不足 512 MB 内存的机器上，通常为 swap 分区分配2倍内存大小的空间。如果有更大的内存（大于 1024 MB），可以分配较少的空间甚至不需要swap 分区。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因此你在网上经常看到的「两倍内存」原则，实际上是以前物理内存较小情况下的普遍原则，现在并不推荐，因为这显然浪费了很多硬盘空间。&lt;/p&gt;

&lt;p&gt;那么选用swap分区还是swap文件呢？同样在Arch Wiki的Partition词条&lt;sup id=&quot;fnref:arch-swap:1&quot;&gt;&lt;a href=&quot;#fn:arch-swap&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;也做了说明：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;swap 分区提供能够被作为虚拟内存的内存空间。swap file 也可以实现同样的功能，并且它们之间没有明显的性能区别，但是后者更易于根据需要调整大小。如果没有使用休眠特性的话，swap 分区可以被多个系统共享。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一般来说不会用到多个系统共享同一个swap分区的情况，并且swap文件还可以在装完系统后创建，非常灵活，&lt;strong&gt;因此使用swap文件是最方便的&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;如果在分区时不创建swap分区，Ubuntu会自动帮你创建swap文件。万一没有swap文件，还可以参照&lt;a href=&quot;https://wiki.archlinux.org/index.php/Swap&quot;&gt;Arch Wiki的Swap词条&lt;/a&gt;或&lt;a href=&quot;https://help.ubuntu.com/community/SwapFaq&quot;&gt;Ubuntu社区Wiki的SwapFaq词条&lt;/a&gt;自行创建swap文件。&lt;/p&gt;

&lt;h2 id=&quot;efi分区&quot;&gt;EFI分区&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;如果你是UEFI引导，必须有一个「EFI分区」&lt;/strong&gt;，文件系统格式为FAT32。注意在Ubuntu中，其挂载点是&lt;code class=&quot;highlighter-rouge&quot;&gt;/boot/efi&lt;/code&gt;，不是Arch Wiki中的&lt;code class=&quot;highlighter-rouge&quot;&gt;/boot&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;/efi&lt;/code&gt;。（因为Arch Wiki毕竟是Arch Linux的Wiki，并不是所有内容都可以不加甄别地使用，只不过大部分内容在Linux世界都通用。）另外对于EFI分区到底分多大这件事，你可以看到很多说法，有说100MB~250MB的，也有说512MB左右的。&lt;a href=&quot;https://superuser.com/questions/1310927/what-is-the-absolute-minimum-size-a-uefi-partition-can-be&quot;&gt;Stack Exchange上这个问题的解答&lt;/a&gt;解释了为什么会有这么多不同的推荐分区大小。如果你的硬盘容量足够，个人建议不妨就按照Arch Wiki分550MB。&lt;/p&gt;

&lt;h2 id=&quot;分区原则&quot;&gt;分区原则&lt;/h2&gt;

&lt;p&gt;个人建议对桌面用户而言，分区应满足下面两条原则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;分区数尽量少，不创建没有必要的分区；&lt;/li&gt;
  &lt;li&gt;把&lt;code class=&quot;highlighter-rouge&quot;&gt;/home&lt;/code&gt;分割出来。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;也就是说，对BIOS引导的系统，至少创建两个分区，分别挂载到&lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;/home&lt;/code&gt;，至多再加一个Swap分区；对UEFI引导的系统，至少创建三个分区，分别挂载到&lt;code class=&quot;highlighter-rouge&quot;&gt;/boot/efi&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;/home&lt;/code&gt;，至多再加一个Swap分区。&lt;/p&gt;

&lt;p&gt;「把&lt;code class=&quot;highlighter-rouge&quot;&gt;/home&lt;/code&gt;分割出来」这一点应该没有什么疑问，因为这是我们手动分区的主要目的。而分区数尽量少则是因为对桌面用户来说，在同一个计算机一般不会安装多个Linux系统，也用不着挂载同一个分区到不同系统的目录，所以没有必要将其他目录专门分区。另外，Arch Wiki中提到可以将&lt;code class=&quot;highlighter-rouge&quot;&gt;/var&lt;/code&gt;目录专门分区，「避免由于大量日志写入造成的磁盘空间耗尽等问题」&lt;sup id=&quot;fnref:arch-var&quot;&gt;&lt;a href=&quot;#fn:arch-var&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;，但是一般桌面用户的&lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;分区已经足够大，且即便磁盘空间耗尽也不会造成特别大的影响（相对服务器而言），用户可以利用Live OS清理磁盘空间。所以，额外的分区反而只会浪费磁盘空间。&lt;/p&gt;

&lt;h2 id=&quot;b与ib&quot;&gt;B与iB&lt;/h2&gt;

&lt;p&gt;在使用分区软件，或者平时查看分区或文件大小时，你可能会看到两种单位，一种以B结尾，如MB、GB，另一种以iB结尾，如MiB、GiB。这二者实际上是有区别的。&lt;/p&gt;

&lt;p&gt;iB结尾的单位以2为底，B结尾的单位以10为底。1KiB是1024Byte，1KB是1000Byte。但是人们经常混用这两个单位，导致现在以B结尾的单位很多时候其实表示以iB结尾。（我全文中所用的MB和GB实际上都指的是MiB和GiB。）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重点来了：许多分区软件默认MB、GB这些单位就是MiB、GiB，可是Ubuntu的安装程序使用的是MB、GB的原本定义。所以在分区时需要做一下MiB到MB，或GiB到MB的转换，以免最后分区的大小与预期不符。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这解释了为什么经常人们发现自己的分区比预期的小一些。我也很不理解为什么Canonical要这么做，为何不使用统一的标准呢？如果想区分B和iB，那完全可以将安装程序中的单位换成iB，现在这么做只会给不明真相的用户造成麻烦。&lt;/p&gt;

&lt;h1 id=&quot;延伸阅读&quot;&gt;延伸阅读&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.rodsbooks.com/efi-bootloaders/secureboot.html&quot;&gt;Managing EFI Boot Loaders for Linux: Dealing with Secure Boot&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://askubuntu.com/questions/843656/is-it-safe-to-disable-secure-boot&quot;&gt;Is it safe to disable Secure Boot? - Ask Ubuntu&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wiki.ubuntu.com/Kernel/Firmware&quot;&gt;Kernel/Firmware - Ubuntu Wiki&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://help.ubuntu.com/community/LiveCD&quot;&gt;LiveCD - Community Help Wiki&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://superuser.com/questions/1310927/what-is-the-absolute-minimum-size-a-uefi-partition-can-be#&quot;&gt;boot - What is the absolute minimum size a UEFI partition can be? - Super User&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wiki.archlinux.org/index.php/Swap&quot;&gt;Swap - ArchWiki&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://help.ubuntu.com/community/SwapFaq&quot;&gt;SwapFaq - Community Help Wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:rod-smith&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://www.rodsbooks.com/efi-bootloaders/secureboot.html&quot;&gt;Managing EFI Boot Loaders for Linux: Dealing with Secure Boot&lt;/a&gt; &lt;a href=&quot;#fnref:rod-smith&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:is-it-safe&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://askubuntu.com/questions/843656/is-it-safe-to-disable-secure-boot&quot;&gt;Is it safe to disable Secure Boot? - Ask Ubuntu&lt;/a&gt; &lt;a href=&quot;#fnref:is-it-safe&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:arch-hibernation&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://wiki.archlinux.org/index.php/Power_management/Suspend_and_hibernate#Hibernation&quot;&gt;Power management/Suspend and hibernate - ArchWiki&lt;/a&gt; &lt;a href=&quot;#fnref:arch-hibernation&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:arch-swap&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://wiki.archlinux.org/index.php/Partitioning_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#Swap&quot;&gt;Partitioning (简体中文) - ArchWiki #Swap&lt;/a&gt; &lt;a href=&quot;#fnref:arch-swap&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt; &lt;a href=&quot;#fnref:arch-swap:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:arch-var&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://wiki.archlinux.org/index.php/Partitioning_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#/var&quot;&gt;Partitioning (简体中文) - ArchWiki #/var&lt;/a&gt; &lt;a href=&quot;#fnref:arch-var&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 08 Feb 2019 00:00:00 -0500</pubDate>
        <link>http://yilin-zhang.github.io/linux%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97/2019/02/08/linux-guide-04-install-ubuntu.html</link>
        <guid isPermaLink="true">http://yilin-zhang.github.io/linux%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97/2019/02/08/linux-guide-04-install-ubuntu.html</guid>
        
        <category>Linux</category>
        
        <category>Ubuntu</category>
        
        
        <category>Linux生存指南</category>
        
      </item>
    
      <item>
        <title>Linux生存指南03 | 基础生存篇 | 目录结构、文件系统与挂载</title>
        <description>&lt;p&gt;也许很多小伙伴都迫不及待想安装上Linux尝尝鲜，但是在介绍安装Linux前，还是想先把Linux的目录结构、文件系统和挂载讲明白。&lt;/p&gt;

&lt;p&gt;这三点是很多初次使用Linux的小伙伴最迷惑的地方。首先在安装时，如果你是按照网上某些细心的教程操作，那么你会看到推荐在安装时进行手动分区（partition）。而在分区的时候，你会被要求给所划的分区选一个文件系统（file system），还需要把它挂载（mount）到某个特定的目录。记得当时自己初次分区时，完全不知道到底应该把某个分区划多大，那么多可选的文件系统是什么意思，也搞不明白那些目录是做什么用的。查阅了网上的很多博客或论坛，每个答案都不太相同。&lt;/p&gt;

&lt;p&gt;另外在自己安装完成后，发现Linux的目录结构也和自己熟悉的Windows不太一样。打开一个名字类似于「主文件夹」的图标后，会看到好几个叫做「文档」、「下载」、「图片」之类的文件夹，有点像Windows的用户目录（其实在Linux也就是用户目录没错）。那软件装在哪里呢？往上级目录翻，发现居然有好多的目录，而且每个目录都是只读的！那每个目录到底是什么意思呢？里面存放着什么样的文件？&lt;/p&gt;

&lt;p&gt;所以这一篇就先来讲讲Linux的目录结构、文件系统和挂载。我会先从容易理解的目录结构说起，然后再给大家介绍关于文件系统和挂载的一些必要知识。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不过「文件系统」和「挂载」两节对于初识Linux的小伙伴来说可能略显硬核，可以暂时略过不看，等到以后想要了解的时候，或者希望将Linux装在物理机上作为桌面操作系统时，再翻回来看。&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;目录结构&quot;&gt;目录结构&lt;/h1&gt;

&lt;h2 id=&quot;树状结构&quot;&gt;树状结构&lt;/h2&gt;

&lt;p&gt;Linux的目录结构是树状结构，与Unix一脉相承（谁让它是类Unix呢）。说句题外话，macOS也是类Unix操作系统，所以目录结构也是树状的。下面给出一张示意图&lt;sup id=&quot;fnref:dirimg&quot;&gt;&lt;a href=&quot;#fn:dirimg&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
&amp;lt;img src=&quot;http://pma51umnw.bkt.clouddn.com/The-Linux-directory-structure.png&quot; width = 70% height = 70%/&amp;gt;
&lt;/div&gt;

&lt;div align=&quot;center&quot;&gt;
Linux目录结构示意图&lt;/div&gt;

&lt;p&gt;我相信大多数小伙伴应该都知道什么叫「树状」。Linux的目录是一颗树，所以只有一个「根节点」，也就是「根目录」，用符号&lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;来表示。注意Linux的路径（path）中，目录之间的分割符是「正斜杠」&lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;，而大家熟悉的Windows使用是「反斜杠」&lt;code class=&quot;highlighter-rouge&quot;&gt;\&lt;/code&gt;，例如&lt;code class=&quot;highlighter-rouge&quot;&gt;C:\windows\system32\&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;根目录&lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;下面有许多的目录，例如&lt;code class=&quot;highlighter-rouge&quot;&gt;/bin&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;/dev&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;/home&lt;/code&gt;等等，有20个左右（上面的示意图只列出了部分目录）。为什么要写成&lt;code class=&quot;highlighter-rouge&quot;&gt;/bin&lt;/code&gt;呢？因为第一个字符&lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;代表根目录，而后面三个字母&lt;code class=&quot;highlighter-rouge&quot;&gt;bin&lt;/code&gt;是该目录的名称，所以如果要标示清楚这个目录的所在路径，就要写成&lt;code class=&quot;highlighter-rouge&quot;&gt;/bin&lt;/code&gt;。如果只是写&lt;code class=&quot;highlighter-rouge&quot;&gt;bin&lt;/code&gt;，你就只能把它当作一个「相对路径」而非「绝对路径」了（这两个概念如果不明白可以在网上轻松找到解答）。&lt;/p&gt;

&lt;h2 id=&quot;家目录与系统目录&quot;&gt;家目录与系统目录&lt;/h2&gt;

&lt;p&gt;这些目录中，最特别的是&lt;code class=&quot;highlighter-rouge&quot;&gt;/home&lt;/code&gt;，因为看名字就知道，这是你的「家」！&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/home&lt;/code&gt;的下级目录是用户目录，这就是前面提到的「主文件夹」。比如我的用户名是&lt;code class=&quot;highlighter-rouge&quot;&gt;yilin&lt;/code&gt;，那么我的用户目录就是&lt;code class=&quot;highlighter-rouge&quot;&gt;/home/yilin&lt;/code&gt;。如果这台计算机有多个用户，比如还有&lt;code class=&quot;highlighter-rouge&quot;&gt;tom&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;jerry&lt;/code&gt;，那么就会有&lt;code class=&quot;highlighter-rouge&quot;&gt;/home/tom&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;/home/jerry&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;需要注意的是，并非所有用户都会有自己的用户目录。在后面会有一个章节介绍有关用户的知识。现在假设用户&lt;code class=&quot;highlighter-rouge&quot;&gt;tom&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;jerry&lt;/code&gt;都是这台计算机的桌面用户，那么一般而言他们都会建立自己的用户目录。&lt;/p&gt;

&lt;p&gt;根目录&lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;下面除了&lt;code class=&quot;highlighter-rouge&quot;&gt;/home&lt;/code&gt;目录以外的其他目录呢？它们都可以视为系统目录。一般我们所谓的「软件」就会安装在这些系统目录下面。除了软件外，系统目录下还存放许多与系统相关的配置文件、日志文件、共享库文件等等。Linux的这些系统文件都会分门别类地放在不同目录下。那么这些目录分别存放的是什么样的文件呢？&lt;a href=&quot;https://www.howtogeek.com/117435/htg-explains-the-linux-directory-structure-explained/&quot;&gt;这篇文章&lt;/a&gt;已经把它们讲得非常清楚了，大家可以看一看，在这里就不多说了。&lt;/p&gt;

&lt;h2 id=&quot;一切皆文件&quot;&gt;一切皆文件&lt;/h2&gt;

&lt;p&gt;如果你看了上面链接的那篇文章，可能会感觉不可思议。为什么硬件也可以当作文件？比如&lt;code class=&quot;highlighter-rouge&quot;&gt;/dev&lt;/code&gt;下存放的都是代表各个硬件的一些文件。甚至&lt;code class=&quot;highlighter-rouge&quot;&gt;/proc&lt;/code&gt;目录里面的文件压根不在硬盘里，你可以通过这些文件读取系统进程的信息，但这些文件的大小都是0。&lt;/p&gt;

&lt;p&gt;这是因为在Unix或类Unix操作系统中，一切皆文件。硬件是文件，目录也是文件，甚至在内存中的信息也可以当作文件。&lt;/p&gt;

&lt;p&gt;也就是说，操作系统以这种方式为用户提供了一套统一的接口。只要你想对某个对象进行操作，不论这个对象到底是什么，去读写文件就可以了。&lt;/p&gt;

&lt;h2 id=&quot;题外话之权限&quot;&gt;题外话之权限&lt;/h2&gt;

&lt;h3 id=&quot;用户权限&quot;&gt;用户权限&lt;/h3&gt;

&lt;p&gt;用户对自己的用户目录是可读可写的。有关权限的问题在后面的章节会讲到，现在你可以简单地理解为：你可以在你的用户目录下查看文件，也可以新建、删除、修改文件。而用户对其他用户的用户目录是默认不可读写的，也就是说其他用户无法查看你的用户目录，更不能进行任何文件操作。&lt;/p&gt;

&lt;p&gt;用户对系统目录只读，也就是说用户只能查看系统目录，但不能修改系统目录中的文件或目录。&lt;/p&gt;

&lt;h3 id=&quot;root真正的boss&quot;&gt;root：真正的boss&lt;/h3&gt;

&lt;p&gt;奇怪了，前面明明说用户对系统文件只读，那如果要按上一节说的对&lt;code class=&quot;highlighter-rouge&quot;&gt;/dev&lt;/code&gt;中的硬件进行操作，该如何写呢？&lt;/p&gt;

&lt;p&gt;实际上在Linux中有一个真正的boss，那就是root用户。root用户可以做任何事，只要Linux允许，你就能做。你可以修改系统文件，也可以偷看&lt;code class=&quot;highlighter-rouge&quot;&gt;tom&lt;/code&gt;的文件。甚至有权限把整个根目录删掉（我在网上看到有人这么做，但没成功，想想也是不太可能）。&lt;/p&gt;

&lt;p&gt;不过，如果你真的想对&lt;code class=&quot;highlighter-rouge&quot;&gt;/dev&lt;/code&gt;中的硬件读写，使用root并不是一个好办法。&lt;strong&gt;实际上总是使用root权限是相当危险的&lt;/strong&gt;，如果不是迫不得已，千万不要总是使用root权限。为什么危险？因为你不能保证自己永远不会误操作，也不能保证你给予权限执行的程序不会错误执行或包含恶意代码。你应当尽量保证所有的操作都在一定权限的控制下，这样才能最大限度保护系统的安全。&lt;/p&gt;

&lt;p&gt;那该怎么办？「用户组」是一个比较合理的解决方案。这个问题会在之后讲用户和用户组的章节中得到解答。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;就像开头说的，如果你初识Linux，可以跳过下面两节，&lt;a href=&quot;#安装时偷个懒&quot;&gt;安装时偷个懒&lt;/a&gt;吧！&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;文件系统&quot;&gt;文件系统&lt;/h1&gt;

&lt;p&gt;理解了上面这些，大家对Linux的目录结构应该有些头绪了。我们还顺便了解了Unix中的「一切皆文件」的概念和关于root的小知识。接下来我们来了解一下与文件系统（file system）相关的知识。&lt;/p&gt;

&lt;h2 id=&quot;什么是文件系统&quot;&gt;什么是文件系统&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;A filesystem is the methods and data structures that an operating system uses to keep track of files on a disk or partition; that is, the way the files are organized on the disk.&lt;sup id=&quot;fnref:fs&quot;&gt;&lt;a href=&quot;#fn:fs&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你可以把你的硬盘比作一个大大的房间，里面放满了一个个小抽屉。这些小抽屉就是文件系统的基本操作单位——盘块（硬盘的最小操作单位是扇区，一个盘块由一个或多个扇区组成）。文件系统就像是这些小抽屉的管理员，它会来决定该以怎样的方式存放你的文件，并将你的文件很好地管理起来。不同的文件系统有不同的管理方法。&lt;/p&gt;

&lt;p&gt;在Linux中，最常用的文件系统是Ext4（fourth extended filesystem，第四代扩展文件系统）。它最多支持1EiB的卷（volume）大小和16TiB的单个文件大小&lt;sup id=&quot;fnref:ext4&quot;&gt;&lt;a href=&quot;#fn:ext4&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;，比Windows使用的NTFS文件系统支持的卷大小和单个文件大小都要大。&lt;/p&gt;

&lt;p&gt;所谓的「卷」又是什么呢？我们先来看什么是「分区」。&lt;/p&gt;

&lt;h2 id=&quot;分区和卷&quot;&gt;分区和卷&lt;/h2&gt;

&lt;p&gt;在安装Linux时，一般推荐的做法是手动分区，所以了解分区（partitioning）是必要的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Disk partitioning or disk slicing is the creation of one or more regions on a hard disk or other secondary storage, so that an operating system can manage information in each region separately.&lt;sup id=&quot;fnref:partition&quot;&gt;&lt;a href=&quot;#fn:partition&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单来说，分区就是我们的硬盘被划分出来的逻辑存储区域。所谓的「逻辑」与「物理」相对。如果将一块硬盘划分为两个分区，那么虽然物理硬盘只有一块，但计算机能看到的逻辑硬盘有两块。分区不一定包含文件系统。&lt;/p&gt;

&lt;p&gt;我们可以将一个分区「格式化（format）」为指定的文件系统，这样一来，这个分区就可以看作一个卷（volume）。注意一个卷只能有一个文件系统。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In computer data storage, a volume or logical drive is a single accessible storage area with a single file system, typically (though not necessarily) resident on a single partition of a hard disk.&lt;sup id=&quot;fnref:volume&quot;&gt;&lt;a href=&quot;#fn:volume&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;另外，在同一个硬盘，我们可以把其中的不同的分区格式化为不同的文件系统。&lt;/p&gt;

&lt;p&gt;所以说，格式化本质上不是把硬盘上的文件删光光的意思，它只是格式化的一个副作用而已。&lt;/p&gt;

&lt;p&gt;那么计算机是如何知道我们硬盘的分区情况的呢？在硬盘上会存储一个分区表，分区表记录了硬盘中各个分区的大小和物理位置。这样一来，计算机就可以通过读取分区表来了解硬盘分区的信息了。&lt;/p&gt;

&lt;p&gt;当今存在两种主流的分区表，一种叫MBR（Master Boot Record，主引导记录），另一种叫GPT（GUID Partition Table，GUID分区表）。&lt;/p&gt;

&lt;p&gt;MBR是硬盘最开始的512个字节。除了分区表，它还包括了操作系统的启动加载器（boot loader）。如果一个硬盘采用的是MBR分区表，那么它所支持的分区有三种类型：主分区（primary）、扩展分区（extened）和逻辑分区（logical）。MBR在一个磁盘上最多只支持4个主分区。如果想要4个以上的分区该怎么办？一般的做法是建立3个主分区和1个扩展分区，再在这个扩展分区中建立1个或多个逻辑分区。注意，扩展分区最多只能有1个，并且扩展分区和主分区加起来不能多于4个。扩展分区中的逻辑分区数没有限制。&lt;sup id=&quot;fnref:archwiki&quot;&gt;&lt;a href=&quot;#fn:archwiki&quot; class=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;GPT分区表是一种更强大的分区表。它只支持主分区，但对其个数没有做限制。&lt;/p&gt;

&lt;p&gt;这么一看，GPT分区表显然要方便得多，那我们就用GPT分区表吧！&lt;/p&gt;

&lt;p&gt;但是实际情况没有那么简单。&lt;/p&gt;

&lt;p&gt;在Arch Wiki&lt;sup id=&quot;fnref:archwiki:1&quot;&gt;&lt;a href=&quot;#fn:archwiki&quot; class=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;中，给出了选择MBR还是GPT时需要考虑的内容，在这里我直接引用过来：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;如果使用 GRUB legacy 作为bootloader，必须使用MBR。&lt;/li&gt;
    &lt;li&gt;如果使用传统的BIOS，并且双启动中包含 Windows（无论是32位版还是64位版），必须使用MBR。&lt;/li&gt;
    &lt;li&gt;如果使用 UEFI 而不是BIOS，并且双启动中包含 Windows 64位版，必须使用GPT。&lt;/li&gt;
    &lt;li&gt;非常老的机器需要使用 MBR，因为 BIOS 可能不支持 GPT.&lt;/li&gt;
    &lt;li&gt;如果不属于上述任何一种情况，可以随意选择使用 GPT 还是 MBR。由于 GPT 更先进，建议选择 GPT。&lt;/li&gt;
    &lt;li&gt;建议在使用 UEFI 的情况下选择 GPT，因为有些 UEFI firmware 不支持从 MBR 启动。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;那么如何确定自己的引导系统是BIOS还是UEFI？网上有非常多教你如何查看自己电脑引导系统的教程。如果你现在用的是Windows，可以查看&lt;a href=&quot;https://itsfoss.com/check-uefi-or-bios/&quot;&gt;这篇文章&lt;/a&gt;。如果你不了解什么是BIOS和UEFI，网上也有非常多的介绍可供学习，我在&lt;a href=&quot;#延伸阅读&quot;&gt;延伸阅读&lt;/a&gt;中也给出了Wikipedia对应词条的链接。&lt;/p&gt;

&lt;h1 id=&quot;挂载&quot;&gt;挂载&lt;/h1&gt;

&lt;p&gt;当你成功地将硬盘分区后，事情还没结束，你还需要将各个分区挂载到不同的挂载点。&lt;/p&gt;

&lt;p&gt;在讲这个问题之前，先来回顾一下大家熟悉的Windows操作系统。&lt;/p&gt;

&lt;h2 id=&quot;windows的盘&quot;&gt;Windows的「盘」&lt;/h2&gt;

&lt;p&gt;当我们的电脑上有多个分区时，你一般会看到所谓的「C盘」、「D盘」、「E盘」……每一个盘都代表一个分区。很直观不是吗？如果你有两块硬盘，还在第一块硬盘分了两个区，你的分区情况有可能是下面这个样子：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;物理硬盘&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;分区&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;文件系统&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;盘符&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;硬盘1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;分区1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;NTFS&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;C:&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;硬盘1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;分区2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;FAT32&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;D:&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;硬盘2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;分区1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;FAT32&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;E:&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Windows是如何获得这些分区信息的？首先它会找到所有的硬盘，在这里是硬盘1和硬盘2，再去找硬盘中的分区，这里有三个分区：硬盘1的分区1和分区2，硬盘2的分区1，然后读取文件系统信息。&lt;sup id=&quot;fnref:howtoread&quot;&gt;&lt;a href=&quot;#fn:howtoread&quot; class=&quot;footnote&quot;&gt;7&lt;/a&gt;&lt;/sup&gt;（盘符在分区格式化时指定，所以应该算作文件系统信息的一部分。）&lt;/p&gt;

&lt;h2 id=&quot;linux的挂载&quot;&gt;Linux的挂载&lt;/h2&gt;

&lt;p&gt;那Linux呢？我们之前在&lt;a href=&quot;#目录结构&quot;&gt;目录结构&lt;/a&gt;一节讲到过，Linux的目录结构是树状结构，而且是&lt;strong&gt;一棵树&lt;/strong&gt;。那该怎么办，难道我只能使用一个分区了吗？&lt;/p&gt;

&lt;p&gt;其实不然。不过在把这件事搞清楚之前，我们需要了解一个概念——虚拟文件系统（Virtual File System, VFS）。想一想，为什么在Windows中，你的C盘是NTFS文件系统，D盘是FAT32文件系统（也许实际上不是，只是举个例子），而你却可以用相同的方式打开他们，创建、修改、删除文件？这是因为操作系统提供了一层在实体文件系统之上的「虚拟文件系统」，抽象了实体文件系统，给用户一套统一的接口去操作不同的文件系统。Windows使用的虚拟文件系统机制叫做（Installable File System）。&lt;sup id=&quot;fnref:volume:1&quot;&gt;&lt;a href=&quot;#fn:volume&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;Linux当然也有虚拟文件系统，而且它更进了一步。记得上文提到的「一切皆文件」吗？就是因为有了虚拟文件系统才能做到这一点。同时，Linux的虚拟文件系统还维护着一个树状结构目录，并且系统需要通过这个虚拟文件系统访问硬盘。也就是说，Linux为了获得分区信息，先通过虚拟文件系统访问硬盘，再访问分区，然后访问文件系统。&lt;sup id=&quot;fnref:howtoread:1&quot;&gt;&lt;a href=&quot;#fn:howtoread&quot; class=&quot;footnote&quot;&gt;7&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;现在我们就可以来了解Linux是怎么做的了。虽然Linux的目录结构只有&lt;strong&gt;一颗树&lt;/strong&gt;，但是有很多目录不是吗？如何将这些目录与硬盘关联起来呢？就是通过挂载。我们的各个分区就可以挂载到不同的目录上。这些被挂载的目录路径就称为「挂载点（mount point）」。&lt;/p&gt;

&lt;p&gt;还是两块硬盘，并在第一块硬盘分了两个区，在Linux中挂载后会怎样呢？可能是下面这个样子：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;物理硬盘&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;分区&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;文件系统&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;挂载点&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;硬盘1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;分区1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;EFI&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/boot/efi&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;硬盘1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;分区2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Ext4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;硬盘2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;分区1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Ext4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/home&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;你可能还是会奇怪，&lt;code class=&quot;highlighter-rouge&quot;&gt;/boot/efi&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;/home&lt;/code&gt;不是&lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;的子目录吗，为什么可以这样作为挂载点？事实情况是，&lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;下面所有除了&lt;code class=&quot;highlighter-rouge&quot;&gt;/boot/efi&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;/home&lt;/code&gt;的目录和文件都存放在硬盘1的分区2。&lt;/p&gt;

&lt;p&gt;虽然Linux的挂载方法乍一看没有Windows那么直观，但是理解后会发现十分巧妙。对于用户而言，你操作的永远是树状结构的目录，而无需关心具体的分区，而且你也不会因为分区损失结构上的层次性。&lt;/p&gt;

&lt;h1 id=&quot;安装时偷个懒&quot;&gt;安装时偷个懒&lt;/h1&gt;

&lt;p&gt;不过话说回来，真的有必要这么复杂吗？如果我只是想安装Linux体验一下，真的需要了解这么多有关文件系统和挂载的知识吗？&lt;/p&gt;

&lt;p&gt;当然不用！前提是你真的只是「体验一下」，而不把它当作日常使用的桌面操作系统。（因为将&lt;code class=&quot;highlighter-rouge&quot;&gt;/home&lt;/code&gt;单独分区才是最推荐的做法。否则如果系统要重装，你的个人文件就会被删掉了。）&lt;/p&gt;

&lt;p&gt;怎么办呢？很简单，在安装的时让安装程序帮你一步搞定。安装的其中一步是让你选择把Linux装在磁盘的哪个地方。如果你想双系统，直接按照提示把Linux装在你预先腾出来的硬盘空间。如果你使用虚拟机，那就更轻松了，直接使用默认的选项就行了，你只需负责点击「下一步」。&lt;/p&gt;

&lt;p&gt;难怪有很多小伙伴装完Linux后完全不知道有分区这回事！&lt;/p&gt;

&lt;p&gt;这么做会发生什么？安装程序基本上会将你所指定的所有磁盘空间都分成一个区并挂载到根目录&lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;，不过除此之外也可能创建一个swap分区（该分区比较特殊，没有挂载点，具体会在下一篇介绍）。&lt;/p&gt;

&lt;p&gt;在下一篇，我会和大家正式介绍如何安装Linux。也许不会太详细，因为相关的教程已经太多太多，甚至你完全不需要教程也可以轻松安装。我主要会和大家分享一些必要的细节和在手动分区安装时踩过的坑。请持续关注哦！&lt;/p&gt;

&lt;h1 id=&quot;延伸阅读&quot;&gt;延伸阅读&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.howtogeek.com/117435/htg-explains-the-linux-directory-structure-explained/&quot;&gt;The Linux Directory Structure, Explained&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Everything_is_a_file&quot;&gt;Everything is a file - Wikipedia&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://opensource.com/article/17/5/introduction-ext4-filesystem&quot;&gt;An introduction to Linux’s EXT4 filesystem&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wiki.archlinux.org/index.php/Partitioning_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)&quot;&gt;Partitioning - Arch Wiki&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/BIOS&quot;&gt;BIOS - Wikipedia&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface&quot;&gt;Unified Extensible Firmware Interface - Wikipedia&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.infoq.cn/article/how-to-read-linux-file-system-and-directory-structure&quot;&gt;比起 Windows，怎样解读 Linux 的文件系统与目录结构？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:dirimg&quot;&gt;
      &lt;p&gt;The Linux directory structure, Tushar Kute, Kabita Ghosh, &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh&quot;&gt;CC BY-NC-SA 4.0&lt;/a&gt; &lt;a href=&quot;#fnref:dirimg&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:fs&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.tldp.org/LDP/sag/html/filesystems.html&quot;&gt;Filesystems - Linux System Administrators Guide&lt;/a&gt; &lt;a href=&quot;#fnref:fs&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:ext4&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Ext4&quot;&gt;Ext4 - Wikipedia&lt;/a&gt; &lt;a href=&quot;#fnref:ext4&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:partition&quot;&gt;
      &lt;p&gt;Levi B. UNIX Administration. 2002. &lt;a href=&quot;#fnref:partition&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:volume&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Volume_(computing)&quot;&gt;Volume (computing) - Wikipedia&lt;/a&gt; &lt;a href=&quot;#fnref:volume&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt; &lt;a href=&quot;#fnref:volume:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:archwiki&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://wiki.archlinux.org/index.php/Partitioning_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)&quot;&gt;Partitioning - Arch Wiki&lt;/a&gt; &lt;a href=&quot;#fnref:archwiki&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt; &lt;a href=&quot;#fnref:archwiki:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:howtoread&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.infoq.cn/article/how-to-read-linux-file-system-and-directory-structure&quot;&gt;比起 Windows，怎样解读 Linux 的文件系统与目录结构？&lt;/a&gt; &lt;a href=&quot;#fnref:howtoread&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt; &lt;a href=&quot;#fnref:howtoread:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 01 Feb 2019 00:00:00 -0500</pubDate>
        <link>http://yilin-zhang.github.io/linux%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97/2019/02/01/linux-guide-03-directory-structure-file-system-and-mounting.html</link>
        <guid isPermaLink="true">http://yilin-zhang.github.io/linux%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97/2019/02/01/linux-guide-03-directory-structure-file-system-and-mounting.html</guid>
        
        <category>Linux</category>
        
        
        <category>Linux生存指南</category>
        
      </item>
    
      <item>
        <title>Linux生存指南02 | 基础生存篇 | Linux简介</title>
        <description>&lt;h1 id=&quot;什么是linux&quot;&gt;什么是Linux&lt;/h1&gt;

&lt;p&gt;前面讲了这么多，都没说清楚Linux到底是什么。&lt;/p&gt;

&lt;p&gt;Linux是一个操作系统&lt;strong&gt;内核&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;什么是操作系统？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;操作系统是作为计算机硬件和计算机用户之间的中介的程序。操作系统的目的是为用户提供方便且有效地执行程序的环境。
操作系统是管理计算机硬件的软件。硬件必须提供合适的机制来保证计算机的正常运行，以及确保系统不受用户程序干扰运行。&lt;sup id=&quot;fnref:os&quot;&gt;&lt;a href=&quot;#fn:os&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;也就是说，操作系统帮助我们屏蔽了硬件操作的细节，保护系统不因程序随意执行而无法正常工作，也让用户更方便地编写和执行程序。然而，不同的操作系统的架构不同，主导的使用逻辑不同，面向的用户群体也不一样。&lt;/p&gt;

&lt;p&gt;那什么是操作系统内核？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;内核，是一个操作系统的核心。它负责管理系统的进程、内存、设备驱动程序、文件和网络系统，决定着系统的性能和稳定性。&lt;sup id=&quot;fnref:kernel&quot;&gt;&lt;a href=&quot;#fn:kernel&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;操作系统内核是操作系统的一部分，它直接与硬件打交道，提供一个操作系统所需的最基础的那些功能。所以仅仅有一个内核是无法构成一个完整的操作系统的。在Linux内核发布前，GNU工程就已经完成了一个类Unix系统除内核外所需的其他组件。因此在Linux内核发布后，GNU工程的组件与Linux内核结合，就构成了GNU/Linux操作系统。&lt;/p&gt;

&lt;p&gt;GNU/Linux这个名字初看上去有些奇怪，它好像是把两个工程的名字强行组合在了一起，而且把GNU放在了最前面。不过这也是GNU方面合理的诉求，毕竟GNU软件在GNU/Linux操作系统中的比重更大一些，并且也希望人们能明白他们所做的贡献。不过这里为了和当前普遍的叫法统一，也为了方便，在不引起歧义时就写做Linux操作系统。&lt;/p&gt;

&lt;p&gt;Linux是Unix操作系统的一个克隆，因此被称为「类Unix操作系统」。这段历史是一个非常有趣的故事，大家如果有兴趣可以在网上找到许多详细的解释，这里就不再赘述了。需要提到的是，GNU工程的目的是制作一个自由（自由意味着开放源代码，允许软件的自由修改和分发）的类Unix操作系统，其名称就叫GNU（GNU本身就是GNU’s Not Unix的递归缩写）。而GNU工程的发起人Richard Stallman也是自由软件运动的发起人，因此GNU自然采用了一套自由软件许可证——GPL（GNU General Public License），而Linux内核也使用了GPL发布。除此之外，其它的操作系统所需的组件也基本采用GPL发布。因此Linux操作系统基本上是一个自由的操作系统。之所以说「基本上」，是因为大多数的Linux发行版（下一节会解释什么是发行版）为了一些硬件支持和更好的用户体验，会包含少量的闭源软件。但总体而言，你所使用的Linux操作系统是自由的。&lt;/p&gt;

&lt;h1 id=&quot;选一个发行版&quot;&gt;选一个发行版&lt;/h1&gt;

&lt;p&gt;GNU/Linux就是个操作系统了！但是事实也没有那么简单。用户希望得到的是一个「开箱即用」的操作系统，预先包含了一些实用且必要的软件包（即便是简洁到连图形安装界面都没有的Arch Linux，也提供了一系列工具帮助和引导用户安装和配置操作系统），并且能免去用户到处找需要的软件包自行编译安装的麻烦（从头搭一个Linux操作系统可不是件容易事，有一个项目叫Linux From Scratch，可以让你体验这种感觉）。所以就有了Linux发行版这回事。Linux发行版囊括了GNU/Linux的基本组件和一些其他的应用软件，给用户提供方便舒适的体验。另外，不同的发行版也有不同的目标用户。比如Ubuntu面向普通的桌面用户，CentOS面向服务器用户，Arch Linux面向喜欢深度定制系统和滚动更新的进阶用户等等。&lt;/p&gt;

&lt;p&gt;具体选择哪一个发行版是很个人化的事情，不过在这里我仍然推荐桌面用户基数最大的Ubuntu。原因有下面这几点：&lt;/p&gt;

&lt;p&gt;参考资料多：因为用户基数大，所以99%自己遇到的问题别人早就遇到过，因此自己总能在网上找到相应的解答。不过如果你是一个Linux老鸟，一定知道Arch Wiki这个Arch Linux的官方维基。Ubuntu的官方文档相比之下逊色太多了。然而无论你是否是Arch用户，都一定能在Arch Wiki上找到有用的信息。&lt;/p&gt;

&lt;p&gt;软件包丰富：Ubuntu基于全宇宙最大的发行版Debian，而Debian是最早的Linux发行版之一。Ubuntu的官方仓库中包数量是所有发行版中最多的，Debian位居第二。（这是因为Ubuntu在Debian包的基础上又加入了很多自己的包。有关软件仓库的内容之后会介绍。）此外，多数提供二进制包的Linux原生开源软件都提供deb包，而deb包正是Debian系操作系统的软件打包格式。&lt;/p&gt;

&lt;p&gt;是许多软件唯一支持的Linux发行版：比如机器人操作系统ROS（Robot Operating System，虽说名字叫操作系统，实际上只是一个软件平台）只支持Ubuntu，还有Steam唯一官方支持的Linux发行版也是Ubuntu（这不是说其它发行版不能使用Steam）。&lt;/p&gt;

&lt;p&gt;开箱即用，对新手友好：Ubuntu已经帮助用户预先安装了一系列软件，并对其做了优化配置，所以免去了对用户而言繁琐的安装和配置软件的过程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;需要说明的是，这个系列博客面向的是Ubuntu用户。&lt;/strong&gt; 不过虽然如此，很多知识是与发行版无关的。所以无论你今后是希望使用Ubuntu还是其它发行版，都可以在这个系列博客中有所收获。&lt;/p&gt;

&lt;h1 id=&quot;选择版本&quot;&gt;选择版本&lt;/h1&gt;

&lt;p&gt;如果你现在进入Ubuntu官方网站的&lt;a href=&quot;https://www.ubuntu.com/download/desktop&quot;&gt;下载页面&lt;/a&gt;，会看到两个版本。一个是Ubuntu 18.04.1 LTS，另一个是Ubuntu 18.10。这二者有什么区别？&lt;/p&gt;

&lt;p&gt;首先你可能会奇怪，为什么一个低版本号的下载链接反而放在了最前面，而且做了很多说明，显然是想要用户去下载的样子。其次这个「LTS」是什么意思？&lt;/p&gt;

&lt;p&gt;这两个问题其实可以一起解答。&lt;/p&gt;

&lt;p&gt;Ubuntu采用的是point release（或称为fixed release）的策略。其版本号简单易懂，前两个数字代表年，后两个数字代表月。18.04就是2018年4月发布的版本，18.10就是2018年10月发布的版本。LTS是（Long Term Support，长期支持）的缩写。LTS版本支持5年的维护时间，在这期间操作系统只会提供必要的安全更新和bug修复，软件仓库中的软件不会加入新特性，这保证了操作系统在其支持期间的稳定性。而非LTS版本只有9个月的维护时间。LTS版本每两年发布一次，非LTS版本每6个月发布一次。也就是说，Ubuntu的下一个LTS版本是20.04，非LTS的下一个版本是19.04。&lt;/p&gt;

&lt;p&gt;所以说，如果自己想使用一个稳定的操作系统，那么使用LTS版本就是最好的选择。而如果你想体验新特性，或是因为存在影响你使用或难以修复的bug，那就去使用最新的非LTS版本吧。&lt;/p&gt;

&lt;h1 id=&quot;版本更新&quot;&gt;版本更新&lt;/h1&gt;

&lt;p&gt;Ubuntu支持从一个版本到下一个版本的更新，当然也包括从一个LTS版本直接跨越到下一个LTS版本的更新。一般而言这样的更新不会出现太大的问题，但如果你曾经根据某些网上的教学，使用了一些奇特的方法修复过你的系统，或对自己的系统做了较大的个性化设置（修改了系统文件），那要格外小心，因为可能会出现一些意想不到的错误。此时最好的方法就是重装系统。你没听错，就是重装（clean/fresh install）。然而重装不意味着你一定要丢失所有的数据。你可以将自己所有的个人数据放入一个指定分区，而在重装时不去格式化这个分区。不过，无论是哪一种方法，在更新前备份自己的数据都是必要的。&lt;/p&gt;

&lt;p&gt;除了point release之外，还有一种版本迭代方式叫做rolling release（滚动更新）。这种更新策略的特点是：小范围、频繁、追求新特性。也许你每隔几天到几周就会有一次更新，并且你的软件包往往都是最新的。这种更新模式的优势是能拥有最新的软件特性，且软件的bug也会因上游的快速修复而迅速得到解决。而这也同样带来了风险。你不能保证此时的更新不会使你的某个重要软件出bug而无法正常工作，也不能肯定这次的更新会不会直接导致你无法启动系统（概率比较小，但仍存在）。另外，如果自己隔很长时间才进行下一次更新（记住Linux从不会强迫你更新），很有可能会搞坏你的系统，因为滚动更新模式默认用户的软件版本是平滑过渡的，一旦突然跨多个版本升级，很容易造成问题。这本身就是一种变相的强迫更新。因此这种更新策略对新手而言尤为不推荐。&lt;/p&gt;

&lt;h1 id=&quot;flavors&quot;&gt;Flavors&lt;/h1&gt;

&lt;p&gt;为什么Linux发行版还有flavors一说，难道Linux能吃吗！？当然不能啦！Flavors这个词在Linux世界中大致有两种含义：第一种是指不同的Linux发行版，第二种是指预置搭载不同桌面环境的同一个发行版。Flavors的第二种含义可以还用另一个词「spins」来表示。我们在这一节说的flavors，是它的第二种含义（因为Ubuntu官方就是用flavors称呼它的那些spins的）。&lt;/p&gt;

&lt;p&gt;有关桌面环境的内容会在后面的一个章节单独介绍。这里只需要知道在Linux的世界中，桌面环境不止一种。当前使用最多的，也是被大多数发行版作为默认桌面环境的，是GNOME 3。还有一款人气很高的桌面环境叫做KDE。此外还有很多其他主流的桌面环境：Cinnamon、MATE、XFCE、LXDE、Budgie等等。&lt;/p&gt;

&lt;p&gt;不同的桌面环境具有不同的特色。GNOME 3和KDE比较占用系统资源，但更为现代。LXDE主打轻量级的桌面环境，不吃资源。MATE是GNOME 2桌面环境的延续，沿用经典的设计和布局……&lt;/p&gt;

&lt;p&gt;Ubuntu默认搭载的桌面环境是GNOME 3。那Ubuntu的其它flavors呢？比如默认搭载KDE的Kubuntu，搭载MATE的Ubuntu MATE，搭载XFCE的Xubuntu等等。在&lt;a href=&quot;https://www.ubuntu.com/download/flavours&quot;&gt;Ubuntu的相关页面&lt;/a&gt;上列出了所有其支持的flavors。&lt;/p&gt;

&lt;p&gt;不同的flavors除了桌面环境的不同之外，也会对系统做出自己的调整。例如Ubuntu MATE主打的是用户友好（user-friendly）的使用体验。因此其在搭载MATE桌面环境的同时，精心设计自己的默认主题，使其具有与Ubuntu一致的视觉效果，并且提供了很多在Ubuntu中没有的对用户十分友好的功能。Ubuntu Studio是专为影音工作而设计的，因此对这方面的系统设置进行了特别优化，也预置了很多与影音制作相关的软件。（虽说当前Linux的影音制作能力还比不上Windows和macOS，但起码你能看到有许多人在努力。）&lt;/p&gt;

&lt;p&gt;每个flavors都可以看作一个独立的发行版，因此也都会有自己的logo，下面这张图&lt;sup id=&quot;fnref:flavors&quot;&gt;&lt;a href=&quot;#fn:flavors&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;展示ubuntu的一部分flavors。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
&amp;lt;img src=&quot;http://pma51umnw.bkt.clouddn.com/ubuntu-official-flavors.jpg&quot; width = 70% height = 70%/&amp;gt;
&lt;/div&gt;

&lt;div align=&quot;center&quot;&gt;
Ubuntu的部分flavors&lt;/div&gt;

&lt;p&gt;不过需要明白的是，同一种发行版的不同flavors使用的是同一个官方软件仓库。也就说即便你使用了Ubuntu的一个flavor，你仍然能使用所有Ubuntu可以获得的软件，并且所有可用于Ubuntu的解决方案（只要其与桌面环境无关）也都适用与这个flavor。&lt;/p&gt;

&lt;p&gt;我个人目前在使用的就是Ubuntu MATE，使用起来非常舒适哦！&lt;/p&gt;

&lt;p&gt;不过具体选择哪一个flavor也是个人喜好，如果你喜欢某一款桌面环境，就去尝尝那个对应的flavor吧！&lt;/p&gt;

&lt;h1 id=&quot;延伸阅读&quot;&gt;延伸阅读&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.gnu.org/gnu/linux-and-gnu.html&quot;&gt;Linux和GNU系统&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.debian.org/releases/stable/mips/ch01s02.html.zh-cn&quot;&gt;什么是GNU/Linux?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.gnu.org/&quot;&gt;GNU Operating System&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.gnu.org/copyleft/gpl.html&quot;&gt;GNU General Public License&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.fsf.org/about/what-is-free-software&quot;&gt;What Is Free Software&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Comparison_of_Linux_distributions&quot;&gt;Comparison of Linux distributions&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wiki.ubuntu.com/LTS&quot;&gt;LTS - Ubuntu Wiki&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.debian.org/releases/&quot;&gt;Debian 发行版本&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://fossbytes.com/rolling-release-vs-fixed-release-distros-which-linux-distributions-are-better/&quot;&gt;Rolling Release Vs. Fixed Release Distros — Which Linux Distributions Are Better?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:os&quot;&gt;
      &lt;p&gt;Silberschatz A. Gal P B. 操作系统概念[M]. 2004. &lt;a href=&quot;#fnref:os&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:kernel&quot;&gt;
      &lt;p&gt;Bovet D P. Cesati M．深入理解LINUX内核：中国电力出版社，2008. &lt;a href=&quot;#fnref:kernel&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:flavors&quot;&gt;
      &lt;p&gt;Ubuntu official flavors, &lt;a href=&quot;https://www.omgubuntu.co.uk/2018/04/ubuntu-flavors-18-04-release-download-features&quot;&gt;Ubuntu 18.04 Flavours Released, Available to Download - OMG! Ubuntu!&lt;/a&gt; &lt;a href=&quot;#fnref:flavors&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 31 Jan 2019 00:00:00 -0500</pubDate>
        <link>http://yilin-zhang.github.io/linux%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97/2019/01/31/linux-guide-02-introduction.html</link>
        <guid isPermaLink="true">http://yilin-zhang.github.io/linux%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97/2019/01/31/linux-guide-02-introduction.html</guid>
        
        <category>Linux</category>
        
        
        <category>Linux生存指南</category>
        
      </item>
    
      <item>
        <title>Linux生存指南01 | 序言</title>
        <description>&lt;p&gt;「如果你没有认真地去尝试另一个系统，你会错过本来能看到的许多风景。它们不一定真的很美，或者让你值回票价，但这个世界上大多数的人都在big companies限定的路上使用电脑使用了一辈子。你确实安逸，但你从没看过道路以外的事物，而那才是真正的自由。&lt;/p&gt;

&lt;p&gt;当你试图跨出那一步的时候，一开始必定都很艰难，但你并不孤单。在使用Linux的路上，你会找到热心的良师益友，嘴臭的世外高人，无数跟你一样的初学者，以及更重要的，你找回了当初那个勇于选择新道路的自己。&lt;/p&gt;

&lt;p&gt;——要是不能选择的话，这世界也太黑暗了。」&lt;/p&gt;

&lt;h1 id=&quot;序言&quot;&gt;序言&lt;/h1&gt;

&lt;p&gt;为什么要把这篇Linux入门指南作为自己博客的开篇呢？&lt;/p&gt;

&lt;p&gt;我从2018年6月开始正式使用Linux，所谓「正式」，就是彻底告别Windows，将自己笔记本电脑的操作系统换成Linux。我初次接触Linux比这更早一些，是大一还是大二已经记不清了。因此我并不是一开始就粗暴地甩开Windows直接投入Linux的怀抱。这看起来也不太现实，因为Windows和Linux（或者说Unix）之间的差别实在太大，如果没有一定的了解，是无法顺利把思维转换过来的。&lt;/p&gt;

&lt;p&gt;我起初学习Linux的理由也许和大多数人不一样。我猜想大部分人学习Linux的原因是自己不得不用到Linux，比如要做智能小车，要架设或管理一个服务器，要做深度学习等等。而我只是因为觉得Linux很有趣。大部分说出这类话的人可能都是天才，我肯定是个例外。（Linus Torvalds因为觉得编程很有趣，写一个操作系统很有趣，所以写出了Linux。当然现在的Linux早就不是Linus一个人的功劳了。）我不过是一个不怎么会编程的「普通用户」，对一个开放且未知的操作系统世界充满好奇而已。&lt;/p&gt;

&lt;p&gt;自己最初看的，是一部是个查过Linux中文教材的人都知道的教材——鸟哥的Linux私房菜。这部教材大而全，关于Linux的很多细节都覆盖到了，但是我没法完整读下去，因为其中的内容对初学者而言过于细枝末节，且其面向的读者是学习Linux服务器运维的人，这显然和我的初衷不符。我看了必要的一些章节后就自己在虚拟机上把玩，但也仅此而已。&lt;/p&gt;

&lt;p&gt;2018年初，我决定尝试把Linux装在物理机上，和Windows并存（dual boot）。安装过程自己早已驾轻就熟，然而装好后发现操作系统的音频控制会出现莫名其妙的bug。经过网上的搜索，发现是自己电脑声卡或声卡驱动的问题，导致无法支持双系统，无奈之下只好移除Linux。还是活在Windows的世界最安稳啊，当时的我就是这么想的。但是对Linux的好奇仍然没有离开我。2018年6月，自己下定决心，换了系统。就这么简单。&lt;/p&gt;

&lt;p&gt;然而当我走进这个崭新的世界后，我发现这个世界将自己引向了一个更大的世界——自由软件。很难形容这种奇妙的感觉，用一个不恰当的比喻，这就像是一个从前一心想成为富豪的穷人看到了共产主义，同时也看到了自己在社群中无法用金钱衡量的重要价值。&lt;/p&gt;

&lt;p&gt;在这大半年间，自己也换过Linux发行版（distro hopping），遇到过无数问题，也为了解决问题或是发掘新鲜事物看了无数博客和Youtube视频，积攒了很多笔记。笔记的内容包括了很多问题解决（trouble shooting）的方法，Linux基础知识和一些工具的配置使用方法。而让我真正写一个入门指南的的原因，是给同学装操作系统和帮同学解决问题的经历。我费了一番功夫给没有任何技术需求的室友推荐Linux，并帮他安装。现在看来这么做有点蠢，因为不能说Linux优于其他操作系统，Linux也不适用于所有人，更不能强迫别人接受Linux的一切。而值得欣慰的是他现在已经完全适应Linux，并且不喜欢Windows了（笑）。在这个过程中，我渐渐明白一个真正的「普通用户」到底希望在Linux中得到什么。此外，帮其他有需求的同学解决问题时，我也感受到经验分享的重要性。在Linux或者自由软件的世界，经验分享无疑会帮助他人少走很多弯路，而这也是社区存在的目的。&lt;/p&gt;

&lt;p&gt;让我真正走出写博客这一步的，是Sacha Chua写的一本小书，叫做A No-Excuses Guide to Blogging。我曾犹豫过是否真的要以这种方式分享自己的经验，因为感觉自己对这么一个深不见底的领域的了解实在太少太少了。但这本书中的一些话确实鼓舞到了我，让我感到经验的分享的必要性。我在下笔的同时，也希望自己能产出一系列高质量的文章，拒绝CSDN式复制粘贴，拒绝琐碎和冗杂，拒绝只有自己看得懂的自言自语。&lt;/p&gt;

&lt;p&gt;总之，希望能以自己的绵薄之力帮到大家。&lt;/p&gt;

&lt;h1 id=&quot;目标和为什么学&quot;&gt;目标和为什么学&lt;/h1&gt;

&lt;p&gt;不同的人因为不同的目的学Linux。无论你的目标是什么，只要你对Linux不太了解，并且有了解的兴趣，我都希望你能够在我的系列博客中有所收获。但是我还是想事先说明，我的系列博客的目标是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;帮助大家将Linux作为日常使用的桌面操作系统。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;很多对Linux有所了解的人都会认为这有些荒唐，尤其在知乎这个「反Linux」情绪严重的平台。为什么荒唐？主要的理由集中在：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;学习成本高&lt;/li&gt;
    &lt;li&gt;容易遇到很多问题，都需要自己投入精力解决&lt;/li&gt;
    &lt;li&gt;Linux的桌面环境不稳定&lt;/li&gt;
    &lt;li&gt;没有多数Windows软件的支持&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;光是这四条就足以把人吓跑了。那为什么还要学习Linux，还把它作为日常使用的操作系统？我也给出我的理由：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;虽然学习成本高，但掌握后能显著提升工作效率&lt;/li&gt;
    &lt;li&gt;用户控制系统，而非系统囚禁用户（对比Windows根本无法关闭的强制更新）&lt;/li&gt;
    &lt;li&gt;自由软件生态（Linux本身开源免费，且其使用的所有软件几乎都是自由软件(开放源代码、免费、可自由修改和分发)，并且你会发现日常使用的90%的商业软件，都有自由软件的替代品，并且能满足多数人的日常需求，这样就用不着费尽心思装那些只能用到其5%的功能的几个G的商业软件还要想办法破解啦！）&lt;/li&gt;
    &lt;li&gt;遇到的问题容易找到简洁明了的答案，对症下药，精准打击（对比Windows的重启、软件重装、系统重装三连）&lt;/li&gt;
    &lt;li&gt;不会中病毒&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;最重要的一点：有趣&lt;/strong&gt;（最奇妙的事情莫过于自己成功解决问题后的感叹：「原来还可以这样！」）&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;那Linux桌面环境不稳定的问题呢？我的答案是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;没有其他商业操作系统那么稳定，但够稳定。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Linux的桌面环境是Linux中一个可有可无的组件。当然啦，要是把它作为桌面操作系统，这必不可少。桌面环境的不稳定，主要来源于过高的可定制性，比如你可以自己写主题或插件把桌面改成任何你想要的样子。但根据亲身体会，桌面环境崩溃或出bug的发生频率实在太低，低到完全可以忽略。并且抛去桌面环境这个不稳定因素不谈，Linux实在太稳定了，不然为什么世界上大部分的服务器都在用Linux？这个优势完全可以弥补桌面环境的瑕疵。（桌面卡死？切到另一个TTY用命令行重启桌面环境就行了。）&lt;/p&gt;

&lt;p&gt;最后，Windows软件的问题？我的答案是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;多数软件都能找到自由软件替代品，还有一些Windows软件可以用通过WINE来运行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果不知道WINE是什么，别着急，在后面的章节会提到。大家关心的国内鹅厂出品的中国特色即时聊天工具可以在Linux上运行。至于Microsoft Office，这的确是Linux的软肋。虽说是软肋，这也是Microsoft亲手造成的，和Linux本身并无多大关系。理论上最好的替代品是Office Online，可惜国内OneDrive被墙，因此最好的替代品实际上是WPS Office。我明白这套软件会给很多人造成困扰，不过首先它能满足最基本的Office文档编辑需求，其次你今后会爱上纯文本文件，越来越少用Office。&lt;/p&gt;

&lt;p&gt;说到这里，我相信仍然有很多人对Linux并没有产生多大兴趣，或者依然抱有疑惑。这很正常，因为Linux并不适合所有人。什么样的人不适合日常使用Linux？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;认为Windows或macOS的功能完全满足需要，且对Linux的世界没有多少好奇&lt;/li&gt;
    &lt;li&gt;需要在Windows或macOS下完成&lt;strong&gt;专业的&lt;/strong&gt;影音制作和编辑工作&lt;/li&gt;
    &lt;li&gt;需要经常在Windows下玩游戏（即便很多在Steam平台的游戏，甚至Steam上的Windows独占游戏都能在Linux下，但使用Windows游戏仍然是一个更好的选择）&lt;/li&gt;
    &lt;li&gt;不希望花费任何精力学习关于操作系统的知识、工具，也不愿意trouble shooting&lt;/li&gt;
    &lt;li&gt;不能接受英文搜索和查阅英文文档&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;什么样的人适合使用Linux？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;对Linux世界好奇&lt;/li&gt;
    &lt;li&gt;希望提升工作效率（尤其是编程工作）&lt;/li&gt;
    &lt;li&gt;学习工作上的硬性需求&lt;/li&gt;
    &lt;li&gt;注重隐私、希望得到自由&lt;/li&gt;
    &lt;li&gt;反感其它商业操作系统的强制更新对计算机和工作造成的影响&lt;/li&gt;
    &lt;li&gt;想要真正掌控自己的计算机&lt;/li&gt;
    &lt;li&gt;没钱买Windows正版（我是在开玩笑）&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;为什么开头要这么啰嗦写这么多呢？就是怕有人看了好久然后觉得自己被骗了！就像我在开头说的，用什么操作系统只是个人选择而已，我也不希望将自己的看法强加于他人。不过只要你真的感兴趣，就请看下去吧！&lt;/p&gt;

</description>
        <pubDate>Wed, 30 Jan 2019 00:00:00 -0500</pubDate>
        <link>http://yilin-zhang.github.io/linux%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97/2019/01/30/linux-guide-01-preface.html</link>
        <guid isPermaLink="true">http://yilin-zhang.github.io/linux%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97/2019/01/30/linux-guide-01-preface.html</guid>
        
        <category>Linux</category>
        
        
        <category>Linux生存指南</category>
        
      </item>
    
  </channel>
</rss>
